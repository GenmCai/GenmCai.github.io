{"pages":[],"posts":[{"title":"CodeForces - 12D Ball 线段树","text":"题意：emmmm，就是题目描述的女性很奇葩，她们去参加国王举办的舞会，而每个女士有B、I、R三种属性，如果她们得知舞会上存在一个比自身所有属性都要高，那么她就会选择跳楼。。。问有多少个要跳楼的女士。 题解：其实很简单，即按照B进行从大到小排序，然后线段树对比I大的区间进行查询最大值，如果最大值大于自身的R那么这位正在查询的女士选择跳楼。最后把这么女士的信息插入到线段树的I点给予R值，即查完再更新。然后查到最后，其中判断成功累积的值就是结果了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define fi first#define se second#define MP make_pair#define P pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define Sca(x) scanf(\"%d\",&amp;x)#define Sca2(x,y) scanf(\"%d%d\",&amp;x,&amp;y)#define Sca3(x,y,z) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z)#define Scl(x) scanf(\"%lld\",&amp;x)#define Scl2(x,y) scanf(\"%lld%lld\",&amp;x,&amp;y)#define Scl3(x,y,z) scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;z)#define Pri(x) printf(\"%d\\n\",x)#define Prl(x) printf(\"%lld\\n\",x)#define For(i,x,y) for(int i=x;i&lt;=y;i++)#define _For(i,x,y) for(int i=x;i&gt;=y;i--)#define FAST_IO std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);#define ll long longconst int INF=0x3f3f3f3f;const ll INFL=0x3f3f3f3f3f3f3f3f;const double Pi = acos(-1.0);using namespace std;template &lt;class T&gt;void tomax(T&amp;a,T b){ a=max(a,b); } template &lt;class T&gt;void tomin(T&amp;a,T b){ a=min(a,b); }const int N=5e5+5;struct Segt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define MID (tree[p].l+tree[p].r)&gt;&gt;1 struct Tree{ int l,r; int val; }tree[N&lt;&lt;2|1]; void pushdown(int p){ tree[p].val=max(tree[lc].val,tree[rc].val); } void build(int l,int r,int p){ tree[p]=Tree{l,r,0}; if(l==r) return ; int mid=MID; if(l&lt;=mid) build(l,mid,lc); if(r&gt;mid) build(mid+1,r,rc); } void updata(int pos,int p,int val){ if(tree[p].l==pos &amp;&amp; tree[p].r==pos){ tomax(tree[p].val,val); return ; } int mid=MID; if(pos&lt;=mid) updata(pos,lc,val); if(pos&gt;mid) updata(pos,rc,val); pushdown(p); } int getmax(int l,int r,int p){ if(l&gt;r) return 0; if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r) return tree[p].val; int maxx=0; int mid=MID; if(l&lt;=mid) tomax(maxx,getmax(l,r,lc)); if(r&gt;mid) tomax(maxx,getmax(l,r,rc)); return maxx; }}t;struct Data{ int a,b,c;}num[N];int tmp[N];bool cmp(Data one, Data tow){ return one.a &gt; tow.a; }int discrete(int n){ sort(tmp+1,tmp+1+n); return unique(tmp+1,tmp+1+n) - tmp;}int main(){ int n; Sca(n); For(i,1,n) Sca(num[i].a); For(i,1,n) { Sca(num[i].b); tmp[i]=num[i].b; } For(i,1,n) Sca(num[i].c); sort(num+1,num+1+n,cmp); int lenb = discrete(n) - 1; For(i,1,n) num[i].b=lower_bound(tmp+1,tmp+1+lenb,num[i].b) - tmp; int ans=0; t.build(1,lenb,1); int minn=num[1].a; int l=1;// For(i,1,n){// cout&lt;&lt;num[i].a&lt;&lt;' '&lt;&lt;num[i].b&lt;&lt;' '&lt;&lt;num[i].c&lt;&lt;endl;// } For(i,2,n){ if(num[i].a&lt;minn){ minn=num[i].a; For(j,l,i-1) t.updata(num[j].b,1,num[j].c); l=i; } if(t.getmax(num[i].b+1,lenb,1) &gt; num[i].c) ans++; } Pri(ans);}//9//7//7//7//5//2//1//1//1","link":"/2019/07/19/CodeForces12D/"},{"title":"Git常用命令","text":"Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 —— 百度百科 PS：这篇博文相当于字典，方便查阅用。而如果想要重零开始学习Git的使用技巧，推荐去廖雪峰的官方网站上学习。还有就是，下面的$都是可以省略的。 基础操作命令$ git init可以通过这个命令把当前目录变成Git可以进行管理的仓库，会生成隐藏的.git文件。 $ git add file_name通过这个命令可以指定的要添加的当前目录中的文件，也可以使用git add .直接上传当前目录下所有的文件。 $ git commit -m ‘’正式提交之前git add所添加的文件，后面则是当前提交所要对自己或者他人说明的信息。比如说'v0.1版本'。 $ git status此命令可以查看仓库当前的状态，包括有哪些修改后的文件没有添加或者提交到仓库中。 $ git diff file_namediff即difference，顾名思义就是查看文件名所对应的文件有什么跟仓库中不同的敌方，显示格式则是Unix通用的diff格式。 $ git log很明显，就是查看当前git的使用日志，俗称历史记。这里面会提供历史的提交记录，在每条提交记录，会有版本回退所需的专属版本号。在后面显示的(HEAD -&gt; 分支名)即这个分支使用的是这条记录的版本。 $ git reflog这个命令记录了每一次的命令，所以版本回退后，忘记了版本号，可以使用这个命令进行查看。 $ cat file_name则是可以查看文件内的内容 $ git rm file_name如果文件管理器中的文件删除了，那么就真正的在版本库中删除，那么就需要这个命令，然后git commit即可，要注意的一点是，如果已经在文件管理器中删除了文件，那git add的效果跟git rm是一样的。 版本回退操作命令$ git reset –hard HEAD^这个命令的意思则是回退到上一个版本。举一反三，HEAD^^则是回到上上个版本。 $ git reset –hard 版本号如果使用了版本回退，那之前的版本就发现用git log无法进行查看，这时就可以使用之前记住的版本号进行回退，不需要全部的输入版本号，当然也不能只输入前几个数字。要让Git知道这个是唯一的，让他知道要找的是谁。 $ git checkout – file_name这个命令可以把file_name文件在工作区的修改全部的撤回，这里有两种情况：1、文件修改后没有放入暂存区，撤销修改后就回到跟版本库中一摸一样的状态。2、已经添加到暂存区，又做出了修改。撤销修改就回到了暂存区后的状态。即回到最近一次git commit或者git add时的状态。 $ git reset HEAD这个命令可以把file_name文件在工作区的修改全部的撤回。把暂存区中的修改回退到工作区，当单单使用HEAD时，就是表示时最新版本。 远程库操作命令$ git remote add origin HTTP_Path|SSH_Path这个命令则是让本地的git关联到远程库中，而其中的origin则是远程库的名字，也可以改成其他的。 $ git push -u origin 分支名则是把本地库中所有内容推送到远程库上。而git push实际上就就是是把当前分支推送到远程。而由于是第一次关联这个远程库，所以加上-u参数，可以让本地的分支跟远程的分支关联起来，在以后的推送或者拉取时就可以简化命令。 $ git clone HTTP_Path|SSH_Path这个命令则是把网上的远程库给克隆下来。 分支操作命令$ git branch查看分支，在前面标有*的是当前使用分支。 $ git branch 分支名创建分支。 $ git checkout 分支名切换分支。 $ git checkout -b 分支名创建+切换分支。 $ git merge 分支名合并某分支到当前分支。 $ git branch -d 分支名删除分支。","link":"/2019/08/07/Git_Cmd/"},{"title":"Python协程学习笔记","text":"协程◆ 协程就是协同多任务 ◆ 协程在一个进程或者是一个线程中执行 ◆ 不需要锁机制 ◆ 对多核CPU的利用——多进程+协程 协程的实现◆ python3.5以前 使用生成器（yield）来实现代码： 1234567891011121314151617def count_down(n): \"\"\" 倒计时效果 \"\"\" while n &gt; 0: yield n n -= 1def yield_test(): while True: n = (yield) print(n)if __name__ == '__main__': rest = yield_test() next(rest) rest.send('6666') ◆ python3.5以后 使用async和await关键字实现代码： 123456789101112131415161718192021import asyncioasync def do_sth(x): \"\"\" 定义协程函数 \"\"\" print('等待中：{0}'.format(x)) # 等待5秒，表现await作用 await asyncio.sleep(x)# 判断是否为协程函数print(asyncio.iscoroutinefunction(do_sth))coroutine = do_sth(5)# 事件的循环队列loop = asyncio.get_event_loop()# 注册任务task = loop.create_task(coroutine)print(task)# 等待协程任务执行结束loop.run_until_complete(task)print(task) asyncio模块◆ get_event_loop()获得事件循环队列 ◆ run_until_complete()注册任务到队列 ◆ 在事件循环中调度其执行前，协程对象不执行任何操作 ◆ asyncio模块用于事件循环 await 关键字◆ 等待协程执行完成 ◆ 当遇到阻塞调用的函数的时候，使用await方法将协程的控制权让出，以便loop调用其他的协程 协程之间的数据通信◆ 嵌套调用 代码： 123456789101112131415import asyncioasync def compute(x, y): print('计算 x + y =&gt; {0}+{1}'.format(x, y)) await asyncio.sleep(3) return x + yasync def get_sum(x, y): rest = await compute(x, y) print('{0} + {1} = {2}'.format(x, y, rest))# 拿到事件循环loop =asyncio.get_event_loop()loop.run_until_complete(get_sum(1, 2))loop.close() ◆ 队列 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 1. 定义一个队列# 2. 让两个协程进行通信# 3. 让其中一个协程往队列中写入数据# 4. 让另一个协程从队列中删除数据import asyncioimport randomasync def add(store, name): \"\"\" 写入数据到队列 :param store: 队列的对象 :return: \"\"\" for i in range(5): # 往队列中添加数字 num = '{0} - {1}'.format(name, i) await asyncio.sleep(random.randint(1, 5)) await store.put(i) print('{2} add one ... {0}, size：{1}'.format( num, store.qsize(), name))async def reduce(store): \"\"\" 从队列中删除数据 :param store: :return: \"\"\" for i in range(10): rest = await store.get() print(' reduce one.. {0}, size：{1}'.format(rest, store.qsize()))if __name__ == '__main__': # 准备一个对列 store = asyncio.Queue(maxsize=5) a1 = add(store, 'a1') a2 = add(store, 'a2') r1 = reduce(store) # 添加到事件队列 loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.gather(a1, a2, r1)) loop.close()","link":"/2019/08/13/Py_Coroutine_1/"},{"title":"POJ - 2777 Count Color 线段树+位运算","text":"Count ColorTime Limit: 1000MS Memory Limit: 65536KTotal Submissions: 55483 Accepted: 16628Description Chosen Problem Solving and Program design as an optional course, you are required to solve all kinds of problems. Here, we get a new problem. There is a very long board with length L centimeter, L is a positive integer, so we can evenly divide the board into L segments, and they are labeled by 1, 2, … L from left to right, each is 1 centimeter long. Now we have to color the board - one segment with only one color. We can do following two operations on the board: “C A B C” Color the board from segment A to segment B with color C. “P A B” Output the number of different colors painted between segment A and segment B (including). In our daily life, we have very few words to describe a color (red, green, blue, yellow…), so you may assume that the total number of different colors T is very small. To make it simple, we express the names of colors as color 1, color 2, … color T. At the beginning, the board was painted in color 1. Now the rest of problem is left to your.Input First line of input contains L (1 &lt;= L &lt;= 100000), T (1 &lt;= T &lt;= 30) and O (1 &lt;= O &lt;= 100000). Here O denotes the number of operations. Following O lines, each contains “C A B C” or “P A B” (here A, B, C are integers, and A may be larger than B) as an operation defined previously.Output Ouput results of the output operation in order, each line contains a number.Sample Input 2 2 4C 1 1 2P 1 2C 2 2 2P 1 2Sample Output 21 题意：可以理解为L为多少个气球，T代表有多少种颜色，O代表操作数。C命令是区间[A,B]的气球染成C颜色，P命令是查询区间[A,B]有多少不同的颜色。题解：一开始的时候是线段树维护大小为30的数组，明显被卡掉了。于是换了个思路，其实就是用二进制做，最大就是1&lt;&lt;L-1，而每一位二进制上代表存在，0代表不存在。于是就能很简单的用位运算进行实现，唯一的难点就是要想到二进制，幸好做这道题的前一天学的是状压dp。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define fi first#define se second#define MP make_pair#define P pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define Sca(x) scanf(\"%d\",&amp;x)#define Sca2(x,y) scanf(\"%d%d\",&amp;x,&amp;y)#define Sca3(x,y,z) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z)#define Scl(x) scanf(\"%lld\",&amp;x)#define Scl2(x,y) scanf(\"%lld%lld\",&amp;x,&amp;y)#define Scl3(x,y,z) scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;z)#define Pri(x) printf(\"%d\\n\",x)#define Prl(x) printf(\"%lld\\n\",x)#define For(i,x,y) for(int i=x;i&lt;=y;i++)#define _For(i,x,y) for(int i=x;i&gt;=y;i--)#define FAST_IO std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);#define ll long longconst int INF=0x3f3f3f3f;const ll INFL=0x3f3f3f3f3f3f3f3f;const double Pi = acos(-1.0);using namespace std;template &lt;class T&gt;void tomax(T&amp;a,T b){ a=max(a,b); } template &lt;class T&gt;void tomin(T&amp;a,T b){ a=min(a,b); }const int N=1e5+5;int T;int color;struct Segt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define MID (tree[p].l+tree[p].r)&gt;&gt;1 struct Tree{ int l,r; int have,lz; inline void init(int left,int right){ l=left; r=right; have=1; lz=0; } inline void updata(int who){ have=who; lz=who; } inline void lable(){ color|=have; } }tree[N&lt;&lt;2|1]; inline void pushdown(int p){ tree[p].have=tree[lc].have|tree[rc].have; } inline void pushup(int p){ tree[lc].updata(tree[p].lz); tree[rc].updata(tree[p].lz); tree[p].lz=0; } void build(int l,int r,int p){ tree[p].init(l,r); if(l==r) return ; int mid=MID; build(l,mid,lc); build(mid+1,r,rc); } void updata(int l,int r,int p,int who){ if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r){ tree[p].updata(who); return ; } if(tree[p].lz) pushup(p); int mid=MID; if(l&lt;=mid) updata(l,r,lc,who); if(r&gt;mid) updata(l,r,rc,who); pushdown(p); } void getans(int l,int r,int p){ if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r){ tree[p].lable(); return ; } if(tree[p].lz) pushup(p); int mid=MID; if(l&lt;=mid) getans(l,r,lc); if(r&gt;mid) getans(l,r,rc); return ; } }t;int main(){ int n,m; Sca3(n,T,m); t.build(1,n,1); while(m--){ char cmd; scanf(\" %c\",&amp;cmd); int A,B; Sca2(A,B); if(A&gt;B) swap(A,B); if(cmd=='C'){ int C; Sca(C); t.updata(A,B,1,1&lt;&lt;(C-1)); } else if(cmd=='P'){ color=0; t.getans(A,B,1); int sum=0; while(color){ if(color&amp;1) sum++; color&gt;&gt;=1; } Pri(sum); } } return 0;}","link":"/2019/07/19/POJ2777/"},{"title":"Python-OS模块-DateTime模块","text":"标准模块——OS模块 函数/变量 描述 environ 包含环境变量的映射 system(command) 在子shell中执行操作系统命令 sep 路径中使用的分隔符 pathsep 分隔不用路径的分割符 linesep 行分隔符（’\\n’、’\\r’或’\\r\\n’） urandom(n) 返回n个字节的强加密随机数据 argv 命令行参数，包括脚本名 getcwd 放回当前所在的目录 modules 一个字典，将模块名映射到加载的模块 path 一个列表，包含要在其中查找模块的目录的名称 platform 一个平台标识符，如sunos5或win32 mkdir/rmdir 创建和删除文件夹 os.path 文件目录相关操作 os.getcwd() 目前位置 os.listdir() 当前位置有哪些文件 os.path.isdir(‘Name’) 是否是文件夹 os.path.isfile(‘Name’) 是否是文件 os.path.exists(‘Name’) 是否存在 os.path.dirname(‘Name’) 文件所在目录 os.path.split(‘Name’) 分为文件所在目录和文件的名称，返回类型为元组 os.path.splitext(‘Name’) 可将文件后缀分出，返回类型为元组 f = os.path.join(‘’,’’,’’) 路径拼接os.path.makedirs(f) 建立目录 标准模块——DateTime模块 函数/变量 描述 timedelta 对日期/时间进行加减操作时作用 date date类表示一个日期 datetime.strftime 将datetime对象格式化成字符串 datetime.strptime 将字符串按照一定的格式转换成datetime对象 time 表示一个时间的类 datetime.now 系统的当前时间 day Datetime对象的属性，类似的还有minute,hour等 days Timedelta的属性，类似的还有minutes,hours等 DateTime模块转换参数表 参数 含义 %A 星期的名称，如Monday %B 月份名，如January %m 用数字表示的月份(01~12) %d 用数字表示月份中的一天(01~31) %Y 四位的年份，如2015 %y 两位的年份，如15 %H 24小时制的小时数(00~23) %I 12小时制的小时数(01~12) %p am或pm %M 分钟数(00~59) %S 秒数(00~61)","link":"/2019/08/08/Py_Os_DateTime/"},{"title":"正则表达式(RegEx)集合（初级）","text":"正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式中的符号 table th:first-of-type { width: 110px; } table th:nth-of-type(3) { width: 135px } 符号 描述 示例 str 匹配文本字符串的字面值str abc str1|str2 匹配正则表达式str1|str2 abc|bca . 匹配任何字符（除\\n） abc.abc ^ 匹配字符串起始部分 ^Dear $ 匹配字符串终止部分 /str1/*str2$ * 匹配0次或者多次前面出现的正则表达式 [A-Za-z0-9]* + 匹配1次或者多次前面出现的正则表达式 [a-z]+\\.com ? 匹配0次或者1次前面出现的正则表达式 str? {N} 匹配N次前面出现的正则表达式 [A-Z]{3} {M,N} 匹配M到N次（包括M和N）前面出现的正则表达式 [0,9]{3,6} […] 匹配括号中说明的字符集的任意单一字符 [abc] […x-y…] 匹配x-y范围中的任意单一字符 [A-Za-z0-9] [^…] 不匹配此字符集中出现的任何一个字符，包括某一范围的字符（如果在此字符集中出现） [^aedv],[^A-Z] (*|+|?|{})? 用于匹配上面频繁出现/重复出现符号的非贪婪版本（*、+、?、{}） .*?[A-Z] (…) 匹配封闭的正则表达式，然后另存为子组 (A(B(C))) 正则表达式中的特殊字符 特殊字符 描述 示例 \\d 匹配任何十进制数字，与[0-9]一致(\\D与\\d相反，不匹配任何十进制数字) f\\d.txt \\w 匹配任何字母数字字符，与[A-Za-z0-9]相同（\\W与之相反） [A-Za-z]\\w+ \\s 匹配任何空格字符，与[\\n\\t\\r\\v\\f]相同(\\S与之相反) of\\sthe \\b 匹配任何单词边界（\\B与之相反） \\bThe\\b \\N 匹配已保存的子组N（参见上面的(…)） price:\\16 \\c 逐字匹配任何特殊字符c（即，仅按照字面意义匹配，不匹配特殊含义） \\.,\\\\,\\* \\A(\\Z) 匹配字符串的起始(结束)（如上面介绍的^和$） \\ADear 正则表达式中的扩展表示法 (?str)在正则表达式中嵌入一个或者多个特殊“标记”参数（或者通过函数/方法） (?:…)表示一个匹配不用保存的分组 (?P&lt;name&gt;)向一个仅由name标识而不是数字ID标识的正则分组匹配 (?P=name)在同一字符串中匹配由(?P)分组的之前文本 (?#…)表示注释，所有内容都被忽略 (?=…)匹配条件是如果…出现在之后的位置，而不使用输入字符串；称作正向前视断言 (?!…)匹配条件是如果…不出现在之后的位置，而不使用输入字符串；称作负向前视断言 (?&lt;=…)匹配条件是如果…出现在之前的位置，而不使用输入字符串；称作正向后视断言 (?&lt;!…)匹配条件是如果…不出现在之前的位置，而不是用输入字符串；称作负向后视断言 (?(id/name)Y|N)如果分组所提供的id或者name（名称）存在，就返回正则表达式的条件匹配Y，如果不存在，就返回N；|N是可选项（也就是说是可省略的）。ps: 有点像C++中的三目运算符 贪婪模式vs非贪婪模式〇 贪婪模式 在整个表达式匹配成功的前提下，尽可能多的匹配 〇 非贪婪模式 在整个表达式匹配成功的前提下，尽可能少的匹配 默认是贪婪模式","link":"/2019/08/05/RE1/"},{"title":"Python多线程学习笔记","text":"进程 -&gt; 线程 -&gt; 协程 线程的介绍重要性◆ 跳槽、面试、决定薪资高度 ◆ 解决”效率”问题 ◆ Python的GIL导致的系列问题 ◆ 通常会混合使用（多进程 + 协程） 进程◆ 是一个执行中的程序 ◆ 每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据 ◆ 操作系统管理其上所有进程的执行，并为这些进程合理地分配时间 ◆ 进程也可通过派生（fork或者spawm）新的进程来执行其他任务 PS：fork在windows上的支持不是太好，代码只可能在Linux上运行的话，建议用fork。 线程◆ 在同一个进程下执行，并共享相同的上下文 ◆ 一个进程中的各个线程与主线程共享同一片数据空间 ◆ 线程包括开始、执行顺序和结束三部分 ◆ 它可以被抢占（中断）和临时挂起（也称为睡眠）——让步 ◆ 一般是以并发方式执行 并发◆ 不等同于并行处理 ◆ 是一种属性——程序、算法或问题的属性 ◆ 并行只是并发问题的可能方法之一 ◆ 如果两个事件互不影响，则两个事件是并发的 多核的利用及GIL概念对多核的利用◆ 单核CPU系统中，不存在真正的并发 ◆ GIL —— 全局解释器锁 ◆ GIL只是强制在任何时候只有一个线程可以执行Python代码 ◆ I/O密集型应用与CPU密集型应用 （架构师和后台开发需要对此有更深的了解） Python对I/O密集型应用会有比较强大的优势，在CPU密集型应用就发挥不出这样的优势了。而为了弥补CPU密集型应用的缺陷，可以进行C或者C++的扩展。 GIL执行顺序 设置GIL 切换进一个线程去运行 执行下面操作之一： ◆ 指定数量的字节码指令 ◆ 线程主动让出控制权（可以调用time.sleep(0)来完成） 把线程设置回睡眠状态（切换出线程） 解锁GIL 重复上述步骤","link":"/2019/08/11/Py_multithreading_1/"},{"title":"CodeForces - 12D Ball 线段树","text":"题目意思就是，road命令连接第A坐标和第B坐标的点。而line则是查看纵坐标C拉出的扫描线过几个联通块，而联通块中的数量和是多少。（具体的可以查看原题） 题解：其实是线段树一个简单的模拟，即并查集找联通块和联通块中点的数量，然后每次更新删除A点和B点的信息，重新建立A点和B点连接后的信息就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define fi first#define se second#define MP make_pair#define P pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define Sca(x) scanf(\"%d\",&amp;x)#define Sca2(x,y) scanf(\"%d%d\",&amp;x,&amp;y)#define Sca3(x,y,z) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z)#define Scl(x) scanf(\"%lld\",&amp;x)#define Scl2(x,y) scanf(\"%lld%lld\",&amp;x,&amp;y)#define Scl3(x,y,z) scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;z)#define Pri(x) printf(\"%d\\n\",x)#define Prl(x) printf(\"%lld\\n\",x)#define For(i,x,y) for(int i=x;i&lt;=y;i++)#define _For(i,x,y) for(int i=x;i&gt;=y;i--)#define FAST_IO std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);#define ll long longconst int INF=0x3f3f3f3f;const ll INFL=0x3f3f3f3f3f3f3f3f;const double Pi = acos(-1.0);using namespace std;template &lt;class T&gt;void tomax(T&amp;a,T b){ a=max(a,b); } template &lt;class T&gt;void tomin(T&amp;a,T b){ a=min(a,b); }const int N=1e5+5;struct Segt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define MID (tree[p].l+tree[p].r)&gt;&gt;1 struct Tree{ int l,r; int uck,val,lz[2]; inline void init(int left,int right){ l=left; r=right; uck=0; val=0; lz[0]=0; lz[1]=0; } void updata(int uckv,int valv){ uck+=uckv; val+=valv; lz[0]+=uckv; lz[1]+=valv; } }tree[N&lt;&lt;2|1]; void pushdown(int p){ tree[p].uck=tree[lc].uck+tree[rc].uck; tree[p].val=tree[lc].val+tree[rc].val; } void pushup(int p){ int one=tree[p].lz[0],two=tree[p].lz[1]; tree[lc].updata(one,two); tree[rc].updata(one,two); tree[p].lz[0]=0; tree[p].lz[1]=0; } void build(int l,int r,int p){ tree[p]=Tree{l,r,0,0,0,0}; if(l==r) return ; int mid=MID; build(l,mid,lc); build(mid+1,r,rc); } void updata(int l,int r,int p,int uckv,int valv){ if(l&gt;r) return ; if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r){ tree[p].updata(uckv,valv); return ; } if(tree[p].lz[0] || tree[p].lz[1]) pushup(p); int mid=MID; if(l&lt;=mid) updata(l,r,lc,uckv,valv); if(r&gt;mid) updata(l,r,rc,uckv,valv); pushdown(p); } P getans(int pos,int p){ if(tree[p].l==pos &amp;&amp; tree[p].r==pos) return MP(tree[p].uck,tree[p].val); if(tree[p].lz[0] || tree[p].lz[1]) pushup(p); int mid=MID; if(pos&lt;=mid) return getans(pos, lc); if(pos&gt;mid) return getans(pos, rc); }}t;struct Up{ int minn,maxx; } up[N];int num[N],tmp[N],uck[N],ans[N];int len=0;int find(int x){ return uck[x]==x ? x : uck[x]=find(uck[x]); }void merge(int x,int y){ int t1(find(x)),t2(find(y)); if(t1!=t2){ t.updata(up[t1].minn+1,up[t1].maxx,1,-1,-ans[t1]); t.updata(up[t2].minn+1,up[t2].maxx,1,-1,-ans[t2]); uck[t2]=t1; ans[t1]+=ans[t2]; tomax(up[t1].maxx,up[t2].maxx); tomin(up[t1].minn,up[t2].minn); t.updata(up[t1].minn+1,up[t1].maxx,1,1,ans[t1]); }}inline void dis(int n){ sort(tmp+1,tmp+1+n); len=unique(tmp+1,tmp+1+n) - tmp - 1; For(i,1,n) num[i]=lower_bound(tmp+1,tmp+1+len,num[i]) - tmp;}inline void init(int n){ dis(n); For(i,1,n){ uck[i]=i; ans[i]=1; up[i]=Up{num[i], num[i]}; }}int main(){ int T; Sca(T); while(T--){ int n; Sca(n); For(i,1,n){ int x; Sca(x); Sca(num[i]); tmp[i]=num[i]; } init(n); t.build(1,len,1); int m; Sca(m); while(m--){ char cmd[10]; scanf(\"%s\",cmd); if(cmd[0]=='r'){ int x,y; Sca2(x,y); x++; y++; merge(x,y); } else if(cmd[0]=='l'){ double x; scanf(\"%lf\",&amp;x); x+=0.5; x = lower_bound(tmp+1,tmp+1+len,x) - tmp; if(x==len+1) puts(\"0 0\"); else{ P out = t.getans(x,1); printf(\"%d %d\\n\",out.fi,out.se); } } } }}","link":"/2019/07/19/UVA11992/"},{"title":"常用正则表达式","text":"正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 — 菜鸟教程 中文字符 [\\u4e00-\\u9fa5] PS：unicode编码 双字节字符（包括汉字在内） [^\\x00-\\xff] 空白行 \\n\\s*\\r Email地址 [\\w!#$%&amp;’+/=?^_`{|}~-]+(?:.[\\w!#$%&amp;’+/=?^_`{|}~-]+)@(?:[\\w](?:[\\w-][\\w])?.)+[\\w](?:[\\w-]*[\\w])? 网址URL [a-zA-z]+://[^\\s]* 国内电话号码 \\d{3}-\\d{8}|\\d{4}-{7,8} 腾讯QQ号 [1-9][0-9]{4,} 中国邮政编码 [1-9]\\d{5}(?!\\d) 18位身份证号 ^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$ （年-月-日）格式日期 ([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))) 正整数 ^[1-9]\\d*$ 负整数 ^-[1-9]\\d*$ 整数 ^-?[1-9]\\d*$ 非负整数（正整数 + 0） ^[1-9]\\d*|0$ 非正整数（负整数 + 0） ^-[1-9]\\d*|0$ 正浮点数 ^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 负浮点数 ^-[1-9]\\d.\\d|-0.\\d[1-9]\\d$ 在线正则表达式测试地址：http://tool.oschina.net/regex/#","link":"/2019/08/06/RE2/"},{"title":"Hexo 绑定个人域名（华为云版）","text":"个人使用的hexo主题是伊卡洛斯(icarus)，虽然应该对下面的操作没有影响，但姑且还是说一下好了。域名控制管理平台是华为云 1.购买域名(华为云版) 1、进入华为云域名注册https://www.huaweicloud.com/product/domain.html，搜索自己喜欢的域名。 2、选择自己喜欢的域名（建议选择常见的，比如说：com，cn，net之类的，考虑到兼容性的问题），然后进行购买。 3、选择好要购买的期限和域名信息模板（没有的自己建一个，里面的要填写的信息没有特别要讲究的）。 Node:要注意的就是域名购买后，域名信息要实名认证成功后，购买的域名才可以被解析（通俗的说：能被使用） 2、绑定域名 前提是域名到账户上，并且成功实名认证后 1、进入华为云控制台，在华为云服务搜索框中搜素 云解析服务 DNS，然后进入。 2、一般来说是在公网解析中，在里面可以看到你购买成功的域名，然后点击解析，不用管其它的，直接点击进行设置。填入信息后，确定即可添加成功。 table th:first-of-type { width: 100px; } 填写目录 填写信息 主机记录 旁边有个问号，里面有详解，我是直接填了www 类型 普通的只需要A、CNAME（详情的可以看后面的跟的说明），我选择的是CNAME 别名 不用管，没用到，选否 线路类型 普通的全网默认就行了 TTL 默认，5分钟 值 CNAME： 填写需要绑定的域名（例：genmcai.github.io） A： 填写需要绑定的IP（查看方法放下面） 权重 可选参数，解析记录的权重，可选参数，默认值为1。取值范围：0~100。当域名有多条某一类型的解析记录时，根据权重数值选择解析记录，权重数值越高，优先级越高 IP查看方法Ctrl+R 进入 运行 输入 cmd ，输入命令 Ping 域名(例：Ping genmcai.github.io) 下面出现的IPv4地址即是 A 所需的值 3、进入github，到存放网站的仓库，Settings -&gt; Options -&gt; GitHub Pages -&gt; Custom domain -&gt; 填写需要绑定的个人域名 点击save后，网站上会提示是否成功，如果失败并且自己解决不了，可以在下面留言，我看到后会尽力帮你解决。 4、最后一步，在hexo的根目录下source 中添加一个无后缀名的文件（文件名：CNAME），里面内容填写个人域名(例：www.genmcai.com，至于有些同学会问怎么写入，这个可以直接先txt填入内容后删掉后缀名，或者用VS code之类的打开无后缀名的文件，也能写入。 这一步可以说挺重要的，如果没有这个文件，hexo g -d提交后，页面就会变成404，这个时候重复第3个步骤就能恢复，不过每次都这样很麻烦，而且可能会清空博客访问记录。 至此，个人域名的绑定就结束了，重新使用自己的个人域名进行访问，就能访问到绑定的hexo了。如果出现错误，有可能是主题版本的原因，也有可能是其他的原因。欢迎有疑问的小伙伴在下面留言。","link":"/2019/08/03/hexo1/"},{"title":"Python内存管理机制","text":"赋值语句内存分析◆ 使用id()方法访问内存地址 ◆ 使用is比较内存引用地址是否相等 在python之中，像数值、字符串、布尔型单纯的赋值，它们只要值相等，那么对应的变量名所在的地址也是相等的，而这就是python对内存管理的优化。相对的，如：[]列表的复制，其所对应的地址却是不同的。 代码： 123456789101112131415def extend_list(val, l=[]): print('---------------------') print(l, id(l)) l.append(val) print(l, id(l)) return llist1 = extend_list(10)list2 = extend_list(123, [])list3 = extend_list('a')print(list1)print(list2)print(list3) 输出如下: 123456789101112---------------------[] 1976185016904[10] 1976185016904---------------------[] 1976215339528[123] 1976215339528---------------------[10] 1976185016904[10, &apos;a&apos;] 1976185016904[10, &apos;a&apos;][123][10, &apos;a&apos;] 结论：对比list1、list2、list3的输出结果后，就能了解在函数中默认的列表，其在python的内存存储机制。list2不同的原因，就在于它使用的是新生成的列表，而list1和list3相同的原因，则是它们使用的是函数中默认的列表，在内存中，它们是同一个。 垃圾回收机制◆ 以引用计数为主，分代收集为辅 ◆ 如果一个对象的引用数为0，Python虚拟机就会回收这个对象的内存 ◆ 引用计数的缺陷是循环引用的问题 代码（1）： 12345678910111213class Cat(object): def __init__(self): print('对象产生了：{0}'.format(id(self))) def __del__(self): print('对象删除了：{0}'.format(id(self)))def f0(): while True: c1 = Cat()if __name__ == '__main__': f0() 输出如下： 12345678对象产生了：1775928937992对象删除了：1775928938312对象产生了：1775928938312对象删除了：1775928937992对象产生了：1775928937992对象删除了：1775928938312对象产生了：1775928938312对象删除了：1775928937992 代码（2）： 1234567891011121314151617class Cat(object): def __init__(self): print('对象产生了：{0}'.format(id(self))) def __del__(self): print('对象删除了：{0}'.format(id(self)))def f1(): l = [] while True: c1 = Cat() l.append(c1) print('列表元素：', len(l), '个')if __name__ == '__main__': f1() 输出如下： 12345678910对象产生了：1627687778248列表元素： 88839 个对象产生了：1627687778312列表元素： 88840 个对象产生了：1627687778376列表元素： 88841 个对象产生了：1627687778440列表元素： 88842 个对象产生了：1627687778504列表元素： 88843 个 结论：对上面两个代码和输出结果对比，能发现。第一个代码因为后续没有再对之前的生成进行使用，所以虽然不是立刻删除，但也是会马上的进行删除，这样，内存的使用空间不会一直的增长。相对的，第二个代码，它把生成的对象存放到了列表之中，这个列表对之前生成的所有对象进行了引用，所以其存在就不会被删除，内存空间早晚会溢出。 引用计数（reference count）◆ 每个对象都存有指向该对象的引用总数 ◆ 查看某个对象的引用计数 sys.getrefcount() ◆ 可以使用del关键词删除某个引用 代码： 12345678910111213141516171819import sysi = 1s = []l2 = sl3 = sl5 = l3print(sys.getrefcount(s))del l2#对象l被引用的数量print(sys.getrefcount(s))print('------------------')print(sys.getrefcount(i))c = iprint(sys.getrefcount(i)) 输出如下： 1234554------------------9697 结论：可以很明显的看出，引用数不一定是从1开始，这涉及到python当中的内存共享的机制。而每一次的直接引用或者间接引用都会使引用数增加，而对s的引用次数的观察，可发现多了1，这是因为当我们输出的时候，也会对其进行引用，所以引用次数会多一次。 垃圾回收◆ 满足特定条件，自动启动垃圾回收 ◆ 当Python运行时，会记录其中分配对象（object allocation）和取消分配对象（object deallocation）的次数 ◆ 当两者的差值高于某个阈(yù)值时，垃圾回收才会启动 ◆ 查看阈值gc.get_threshold() gc — Garbage Collector interface 代码： 123import gcprint(gc.get_threshold()) 输出如下： 1(700, 10, 10) 分代回收◆ Python将所有的对象分为0，1，2三代 ◆ 所有的新建对象都是0代对象 ◆ 当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象 PS：即初始为0代，每次回收不掉，就对其进行代数的提升，最高为2代。而其有阈值存在，当0代回收次数到达一定的阈值，才会回收1代，而1代回收到一定的阈值，才会回收2代。而1代和2代的回收，会把前面的回收再执行。 手动回收◆ gc.collect()手动回收 ◆ objgraph模块中的count()记录当前类产生的实例对象的个数 代码（1）: 123456789101112131415161718192021222324252627import gc, sysimport objgraphprint(gc.get_threshold())class Persion(object): passclass Cat(object): passp = Persion()c = Cat()p.name = 'Susan'p.pet = cc.master = pprint(sys.getrefcount(p))print(sys.getrefcount(c))del pdel c# 手动执行垃圾回收gc.collect()print(objgraph.count('Persion'))print(objgraph.count('Cat')) 输出如下： 12345(700, 10, 10)3300 代码（2）： 123# 上面代码注释掉这两行代码# del p# del c 输出如下： 12345(700, 10, 10)3311 结论：如果不进行手动回收，那么就会导致回收不掉的。 内存管理机制◆ 内存池(memory pool)机制 当创建大量消耗小内存的对象时，频繁调用new/malloc会导致大量的内存碎片，致使效率降低。内存池的概念就是预先再内存中申请一定数量的，大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。 ◆ Python3中的内存管理机制——Pymalloc 针对小对象（&lt;=512bytes），pymalloc会在内存池中申请内存空间 当&gt;512bytes，则会PyMem_RawMalloc()和PyMem_RawRealloc()来申请新的内存空间 ◆ 单位换算1 Byte = 8 Bit （即 1B = 8b）1 KB = 1024 Bytes1 MB = 1024 KB1 GB = 1024 MB1 TB = 1024 GB1 PB = 1024 TB1 EB = 1024 PB1 ZB = 1024 EB1 YB = 1024 ZBPS：Bit意为”位”或”比特”，时计算机运算的基础，属于二进制的范畴；Byte意为”字节”，时计算机文件大小的基础计算单位。 结论 慕课网 时间_记录昨天 ： 从三方面来说：引用计数、垃圾回收机制、内存池机制。可以根据一下描述进行理解 一、对象的引用计数机制 Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。 引用计数增加的情况： 1、一个对象分配一个新名称 2、将其放入一个容器中（如列表、元组或字典） 引用计数减少的情况： 1、使用del语句对对象别名显示的销毁 2、引用超出作用域或被重新赋值 sys.getrefcount( )函数可以获得对象的当前引用计数 多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。 二、垃圾回收 1、当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。 2、当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。 三、内存池机制 1、Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。 2、Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。 3、Python中所有小于256个字节的对象都是用pymalloc实现的分配器，而大的对象则使用系统的malloc，另外Python对象比如整数浮点数和list都有独立的私有内存池，对象间不共享他们的内存池，也就是说你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。","link":"/2019/08/10/Py_Mem_1/"},{"title":"Python线程学习笔记","text":"实现一个线程◆ 用threading模块代替thread模块 ◆ 用threading.Tread创建线程 ◆ start()启动线程 ◆ join()挂起线程 threading 模块的对象 对象 描述 Thread 表示一个执行线程的对象 Lock 锁原语对象（和thread模块中的锁一样） RLock 可重入锁对象，使单一线程可以（再次）获得已持有的锁（递归锁） Condition 条件变量对象，使得一个线程等待另一个线程满足特定的”条件”，比如改变状态或某个数据值 Event 条件变量的通用版本，任意数量的线程等待某个事件的发生，在该事件发生后所有线程将被激活 Semaphore 为线程间共享的有限资源提供了一个”计数器”，如果没有可用资源时会被阻塞 BoundedSemaphore 与Semaphore相似，不过它不允许超过初始值 Timer 与Thread相似，不过它不允许超过初始值 Barrier 创建一个”障碍”，必须达到指定数量的线程后才可以继续 Thread 对象数据属性 属性 描述 name 线程名 ident 线程的标识符 daemon 布尔标志，表示这个线程是否是守护线程 Thread 对象方法 属性 描述 init() 实例化一个进程对象，需要有一个可以调用的target，以及其参数args或kwargs。 start() 开始执行该线程 run() 定义线程功能的方法（通常在子类中被应用开发者重写） join(timeout=None) 直至启动的线程终止之前一直挂起；除非给出了timeout(秒)，否者会一直阻塞 getName() 返回线程名 setName(name) 设定线程名 isAlivel/is_alive() 布尔标志，表示这个线程是否还存活 isDaemon() 如果是守护线程，则返回True;否则，返回False setDaemon() 把线程的守护标志设定为布尔值daemonic（必须在线程start()之前调用） 代码： 123456789101112131415161718192021222324252627282930import threadingimport timedef loop(): \"\"\" 新的线程执行的代码 \"\"\" now_thread = threading.current_thread() print('[loop]now thread name: {0}'.format(now_thread.name)) n = 0 while n &lt; 5: print(n) time.sleep(1) n += 1def use_thread(): \"\"\" 使用线程来实现 \"\"\" # 当前正在执行的线程名称 now_thread = threading.current_thread() print('now thread name：{0}'.format(now_thread.name)) #设置线程 t = threading.Thread(target=loop, name='loop_thread') # 启动线程 t.start() # 挂起线程 t.join()if __name__ == '__main__': use_thread() 输出如下： 1234567now thread name：MainThread[loop]now thread name: loop_thread01234 观察上面的代码和其输出可以发现，本来是由主线程进行的运行，经过新设置的线程后，变成由新线程进行运行 类形式代码： 123456789101112131415161718192021import threadingimport timeclass LoopThread(threading.Thread): \"\"\" 自定义线程 \"\"\" n = 0 def run(self): while self.n &lt; 5: print(self.n) now_thread = threading.current_thread() print('[loop]now thread name: {0}'.format(now_thread.name)) time.sleep(1) self.n += 1if __name__ == '__main__': t = LoopThread(name='loop_thread_oop') t.start() t.join() 实现多个线程代码如下： 123456789101112131415161718192021222324252627282930313233343536373839import threading# 我的银行账户import timebalance = 0def change_it(n): \"\"\" 改变我的余额 \"\"\" global balance balance = balance + n time.sleep(2) balance = balance - n time.sleep(1) print('-N---&gt; {0}; balance：{1}'.format(n, balance))class ChangeBalanceThread(threading.Thread): \"\"\" 改变银行余额的线程 \"\"\" def __init__(self, num, *args, **kwargs): super().__init__(*args, **kwargs) self.num = num def run(self): for i in range(1000000): change_it(self.num)if __name__ == '__main__': t1 = ChangeBalanceThread(5) t2 = ChangeBalanceThread(8) t1.start() t2.start() t1.join() t2.join() print('the last: {0}'.format(balance)) 输出如下： 123456789-N---&gt; 5; balance：0-N---&gt; 8; balance：5-N---&gt; 5; balance：0-N---&gt; 8; balance：5-N---&gt; 5; balance：0-N---&gt; 8; balance：5-N---&gt; 5; balance：0-N---&gt; 8; balance：5...... PS: global是全局变量的声明，为了让范围比我大的别人用我的东西，使用的时候要和作用域关联起来。 多线程中的锁实现 ◆ Lock() ◆ Rlock() ◆ Condition() Lock()代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import threadingimport time# 获得一把锁my_lock = threading.Lock()# 我的银行账户balance = 0def change_it(n): \"\"\" 改变我的余额 \"\"\" global balance try: # 添加锁 my_lock.acquire() balance = balance + n time.sleep(2) balance = balance - n time.sleep(1) print('-N---&gt; {0}; balance：{1}'.format(n, balance)) finally: # 释放掉锁 my_lock.release()class ChangeBalanceThread(threading.Thread): \"\"\" 改变银行余额的线程 \"\"\" def __init__(self, num, *args, **kwargs): super().__init__(*args, **kwargs) self.num = num def run(self): for i in range(1000000): change_it(self.num)if __name__ == '__main__': t1 = ChangeBalanceThread(5) t2 = ChangeBalanceThread(8) t1.start() t2.start() t1.join() t2.join() print('the last: {0}'.format(balance)) 输出如下： 12345678-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0...... 添加： 1234# 添加锁my_lock.acquire()# 资源已经被锁住了，不能重复锁定，产生死锁my_lock.acquire() 资源已经被锁住了，不能重复锁定，产生死锁 RLock()代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import threadingimport time# 获得一把锁your_lock = threading.RLock()# 我的银行账户balance = 0def change_it(n): \"\"\" 改变我的余额 \"\"\" global balance try: # 添加锁 your_lock.acquire() # 资源已经被锁住了，不能重复锁定，产生死锁 your_lock.acquire() balance = balance + n time.sleep(2) balance = balance - n time.sleep(1) print('-N---&gt; {0}; balance：{1}'.format(n, balance)) finally: # 释放掉锁 your_lock.release() your_lock.release()class ChangeBalanceThread(threading.Thread): \"\"\" 改变银行余额的线程 \"\"\" def __init__(self, num, *args, **kwargs): super().__init__(*args, **kwargs) self.num = num def run(self): for i in range(1000000): change_it(self.num)if __name__ == '__main__': t1 = ChangeBalanceThread(5) t2 = ChangeBalanceThread(8) t1.start() t2.start() t1.join() t2.join() print('the last: {0}'.format(balance)) 输出如下： 12345678-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0...... 在一个线程中锁住，还能再锁。 对锁使用的优化（自动释放，效率会变慢，但安全性提升）： 123456with your_lock: balance = balance + n time.sleep(2) balance = balance - n time.sleep(1) print('-N---&gt; {0}; balance：{1}'.format(n, balance)) 线程的调度和优化 我们的电脑和服务器是有限制的，线程是有上限的，不会无限制的暴力使用，所以在这里就需要进行优化，于是就有了内存池的概念。即建立一个池，当其中的线程完成自己的任务后，让其继续完成池子中未完成的任务，而不是直接销毁掉。 下面使用两种线程的调度和优化的方法 使用multiprocessing模块代码： 123456789101112131415161718192021222324import timeimport threadingfrom multiprocessing.dummy import Pooldef run(n): \"\"\" 线程要做的事情 \"\"\" time.sleep(2) print(threading.current_thread().name, n) def main_use_pool(): \"\"\" 使用线程池来优化 \"\"\" t1 = time.time() n_list = range(100) pool = Pool(10) pool.map(run, n_list) pool.close() pool.join() print(time.time() - t1)if __name__ == '__main__': main_use_pool() 输出如下： 12345678······Thread-6 91Thread-3 94Thread-8 97Thread-6 92Thread-3 95Thread-8 9824.017276763916016 PS: multiprocessing模块中有dummy.pool()和pool.Pool,前者是给线程用的，后者是给进程用的。 使用ThreadPoolExecutor类代码： 12345678910111213141516171819202122import timeimport threadingfrom concurrent.futures.thread import ThreadPoolExecutordef run(n): \"\"\" 线程要做的事情 \"\"\" time.sleep(2) print(threading.current_thread().name, n)def main_use_executor(): \"\"\" 使用 ThreadPoolExecutor 来优化\"\"\" t1 = time.time() n_list = range(100) with ThreadPoolExecutor(max_workers=10) as executor: executor.map(run, n_list) print(time.time() - t1)if __name__ == '__main__': main_use_executor() 输出如下： 123456789······ThreadPoolExecutor-0_4 93ThreadPoolExecutor-0_1 92ThreadPoolExecutor-0_6 95ThreadPoolExecutor-0_3 97ThreadPoolExecutor-0_8 98ThreadPoolExecutor-0_5 96ThreadPoolExecutor-0_7 9920.01082682609558 对比两种方法的运行的时间，确实ThreadPoolExecutor效率相对比较高一些","link":"/2019/08/12/Py_thread_1/"},{"title":"Python进程学习笔记","text":"进程◆ 是一个执行中的程序 ◆ 每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据 ◆ 操作系统管理其上所有进程的执行，并为这些进程合理地分配时间 ◆ 进成也可通过派生（fork 或 spawn）新的进程来执行其他任务 PS：fork在windows上的支持不是太好，代码只可能在Linux上运行的话，建议用fork。 进程模块◆ 使用multiprocessing实现多进程代码 ◆ 用multiprocessing.Process创建进程 ◆ start()启动进程 ◆ join()挂起进程 ◆ os.getpid()获得进程的ID 进程的实现函数实现：123456789101112131415161718192021import os, timefrom multiprocessing import Processdef do_sth(name): \"\"\" 进程要做的事情 :param name: str 进程的名称 :return: \"\"\" print('进程名称：{0}， pid：{1}'.format(name, os.getpid())) time.sleep(150) print('进程要做的事情')if __name__ == '__main__': p = Process(target=do_sth, args=('my process', )) # 启动进程 p.start() # 挂起进程 p.join() 面向对象实现：123456789101112131415161718192021import os, timefrom multiprocessing import Processclass MyProcess(Process): def __init__(self, name, *args, **kwargs): super().__init__(*args, **kwargs) self.my_name = name def run(self): print('MyProcess进程的名称：{0}，pid: {1}'.format(self.my_name, os.getpid())) time.sleep(150) print('MyProcess进程要做的事情')if __name__ == '__main__': p = MyProcess('my process class') # 启动进程 p.start() # 挂起进程 p.join() 可以在任务管理器中找到对应的进程。 进程之间的通信◆ 通过Queue、Pipes等实现进程之间的通信 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import timefrom multiprocessing import Process, Queue, current_processimport randomimport timeclass WriteProcess(Process): \"\"\" 写的进程 \"\"\" def __init__(self, q, *args, **kwargs): super().__init__(*args, **kwargs) self.q = q def run(self): \"\"\" 实现进程的业务逻辑 \"\"\" # 要写的内容 ls = [ \"第1行内容\", \"第2行内容\", \"第3行内容\", \"第4行内容\", ] for line in ls: print('写入内容：{0} - {1}'.format(line, current_process().name)) self.q.put(line) # 每写入一次，休息1-5秒 time.sleep(random.randint(1, 5))class ReadProcess(Process): \"\"\" 读取内容进程 \"\"\" def __init__(self, q, *args, **kwargs): super().__init__(*args, **kwargs) self.q = q def run(self): while True: content = self.q.get() print('读取到的内容：{0} - {1}'.format(content, self.name))if __name__ == '__main__': # 通过Queue共享数据 q = Queue() # 写入内容的进程 t_write = WriteProcess(q) t_write.start() # 读取进程启动 t_read = ReadProcess(q) t_read.start() t_write.join() # t_read.join() # 因为读的进程是死循环，无法等待其结束，只能强制终止 t_read.terminate() 即使用数据对象进行通信 多进程中的锁◆ Lock() ◆ Rlock() ◆ Condition() PS：进程的锁是为了防止共享数据产生错误，从而加锁保证每次操作数据只有一个进程，且牺牲了多进程的并行执行效率。 Lock()代码： 1234567891011121314151617181920212223242526272829303132333435363738394041import randomimport timefrom multiprocessing import Process, Lockclass WriteProcess(Process): \"\"\" 写入文件 \"\"\" def __init__(self, file_name, num, lock, *args, **kwargs): # 文件的名称 super().__init__(*args, **kwargs) self.file_name = file_name self.num = num # 锁对象 self.lock = lock def run(self): \"\"\" 写入文件的主要业务逻辑 \"\"\" try: # 添加锁 self.lock.acquire() for i in range(5): content = '现在是：{0} : {1} - {2}\\n'.format( self.name, self.pid, self.num ) with open(self.file_name, 'a+', encoding='utf-8') as f: f.write(content) time.sleep(random.randint(1,5)) print(content) finally: self.lock.release()if __name__ == '__main__': file_name = 'test.txt' # 锁的对象 lock = Lock() for x in range(5): p = WriteProcess(file_name, x, lock) p.start() Rlock()代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import randomimport timefrom multiprocessing import Process, RLockclass WriteProcess(Process): \"\"\" 写入文件 \"\"\" def __init__(self, file_name, num, rlock, *args, **kwargs): # 文件的名称 super().__init__(*args, **kwargs) self.file_name = file_name self.num = num # 锁对象 self.rlock = rlock def run(self): \"\"\" 写入文件的主要业务逻辑 \"\"\" try: # 添加锁 self.rlock.acquire() print('locked') self.rlock.acquire() print('relocked') for i in range(5): content = '现在是：{0} : {1} - {2}\\n'.format( self.name, self.pid, self.num ) with open(self.file_name, 'a+', encoding='utf-8') as f: f.write(content) time.sleep(random.randint(1,5)) print(content) finally: self.rlock.release() self.rlock.release()if __name__ == '__main__': file_name = 'test.txt' # 锁的对象 rlock = RLock() for x in range(5): p = WriteProcess(file_name, x, rlock) p.start() RLock可重复锁，而Lock能重复锁，反而会导致死锁，导致程序无法正常运行，同线程的锁，有共同之处。 同样，可以使用with进行锁的添加和释放。 使用进程池同步添加任务代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import randomimport timefrom multiprocessing import Process, RLockclass WriteProcess(Process): \"\"\" 写入文件 \"\"\" def __init__(self, file_name, num, rlock, *args, **kwargs): # 文件的名称 super().__init__(*args, **kwargs) self.file_name = file_name self.num = num # 锁对象 self.rlock = rlock def run(self): \"\"\" 写入文件的主要业务逻辑 \"\"\" try: # 添加锁 self.rlock.acquire() print('locked') self.rlock.acquire() print('relocked') for i in range(5): content = '现在是：{0} : {1} - {2}\\n'.format( self.name, self.pid, self.num ) with open(self.file_name, 'a+', encoding='utf-8') as f: f.write(content) time.sleep(random.randint(1,5)) print(content) finally: self.rlock.release() self.rlock.release()if __name__ == '__main__': file_name = 'test.txt' # 锁的对象 rlock = RLock() for x in range(5): p = WriteProcess(file_name, x, rlock) p.start() 异步添加任务代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import randomimport timefrom multiprocessing import current_process, Pooldef run(file_name, num): \"\"\" 进程执行的业务逻辑 往文件中写入数据 :param file_name: str 文件名称 :param num: int 写入的数字 :return: str 写入的结果 \"\"\" with open(file_name, 'a+', encoding='utf-8') as f: # 当前的进程 now_process = current_process() # 写入的内容 content = '{0} - {1} - {2}'.format( now_process.name, now_process.pid, num ) f.write(content) f.write('\\n') # 写完之后随机休息1-5秒 time.sleep(random.randint(1, 5)) print(content) return 'ok'if __name__ == '__main__': file_name = 'test_pool.txt' # 进程池 pool = Pool(2) rest_list = [] for i in range(20): # 异步添加任务 rest = pool.apply_async(run, args=(file_name, i)) rest_list.append(rest) print('{0} --- {1}'.format(i ,rest)) # 关闭池子 pool.close() pool.join() # 查看异步执行的结果 print(rest_list[0].get()) PS：如果要用进程池的话，最好是用函数的方法实现，面向对象的方法相对的会比较麻烦。","link":"/2019/08/13/Py_process_1/"}],"tags":[{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"位运算","slug":"位运算","link":"/tags/位运算/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/正则表达式/"},{"name":"并查集","slug":"并查集","link":"/tags/并查集/"},{"name":"模拟","slug":"模拟","link":"/tags/模拟/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"内存管理","slug":"内存管理","link":"/tags/内存管理/"}],"categories":[{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"正则表达式","slug":"正则表达式","link":"/categories/正则表达式/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"}]}