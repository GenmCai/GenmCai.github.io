{"pages":[],"posts":[{"title":"CodeForces - 12D Ball 线段树","text":"题目意思就是，road命令连接第A坐标和第B坐标的点。而line则是查看纵坐标C拉出的扫描线过几个联通块，而联通块中的数量和是多少。（具体的可以查看原题） 题解：其实是线段树一个简单的模拟，即并查集找联通块和联通块中点的数量，然后每次更新删除A点和B点的信息，重新建立A点和B点连接后的信息就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define fi first#define se second#define MP make_pair#define P pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define Sca(x) scanf(\"%d\",&amp;x)#define Sca2(x,y) scanf(\"%d%d\",&amp;x,&amp;y)#define Sca3(x,y,z) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z)#define Scl(x) scanf(\"%lld\",&amp;x)#define Scl2(x,y) scanf(\"%lld%lld\",&amp;x,&amp;y)#define Scl3(x,y,z) scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;z)#define Pri(x) printf(\"%d\\n\",x)#define Prl(x) printf(\"%lld\\n\",x)#define For(i,x,y) for(int i=x;i&lt;=y;i++)#define _For(i,x,y) for(int i=x;i&gt;=y;i--)#define FAST_IO std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);#define ll long longconst int INF=0x3f3f3f3f;const ll INFL=0x3f3f3f3f3f3f3f3f;const double Pi = acos(-1.0);using namespace std;template &lt;class T&gt;void tomax(T&amp;a,T b){ a=max(a,b); } template &lt;class T&gt;void tomin(T&amp;a,T b){ a=min(a,b); }const int N=1e5+5;struct Segt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define MID (tree[p].l+tree[p].r)&gt;&gt;1 struct Tree{ int l,r; int uck,val,lz[2]; inline void init(int left,int right){ l=left; r=right; uck=0; val=0; lz[0]=0; lz[1]=0; } void updata(int uckv,int valv){ uck+=uckv; val+=valv; lz[0]+=uckv; lz[1]+=valv; } }tree[N&lt;&lt;2|1]; void pushdown(int p){ tree[p].uck=tree[lc].uck+tree[rc].uck; tree[p].val=tree[lc].val+tree[rc].val; } void pushup(int p){ int one=tree[p].lz[0],two=tree[p].lz[1]; tree[lc].updata(one,two); tree[rc].updata(one,two); tree[p].lz[0]=0; tree[p].lz[1]=0; } void build(int l,int r,int p){ tree[p]=Tree{l,r,0,0,0,0}; if(l==r) return ; int mid=MID; build(l,mid,lc); build(mid+1,r,rc); } void updata(int l,int r,int p,int uckv,int valv){ if(l&gt;r) return ; if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r){ tree[p].updata(uckv,valv); return ; } if(tree[p].lz[0] || tree[p].lz[1]) pushup(p); int mid=MID; if(l&lt;=mid) updata(l,r,lc,uckv,valv); if(r&gt;mid) updata(l,r,rc,uckv,valv); pushdown(p); } P getans(int pos,int p){ if(tree[p].l==pos &amp;&amp; tree[p].r==pos) return MP(tree[p].uck,tree[p].val); if(tree[p].lz[0] || tree[p].lz[1]) pushup(p); int mid=MID; if(pos&lt;=mid) return getans(pos, lc); if(pos&gt;mid) return getans(pos, rc); }}t;struct Up{ int minn,maxx; } up[N];int num[N],tmp[N],uck[N],ans[N];int len=0;int find(int x){ return uck[x]==x ? x : uck[x]=find(uck[x]); }void merge(int x,int y){ int t1(find(x)),t2(find(y)); if(t1!=t2){ t.updata(up[t1].minn+1,up[t1].maxx,1,-1,-ans[t1]); t.updata(up[t2].minn+1,up[t2].maxx,1,-1,-ans[t2]); uck[t2]=t1; ans[t1]+=ans[t2]; tomax(up[t1].maxx,up[t2].maxx); tomin(up[t1].minn,up[t2].minn); t.updata(up[t1].minn+1,up[t1].maxx,1,1,ans[t1]); }}inline void dis(int n){ sort(tmp+1,tmp+1+n); len=unique(tmp+1,tmp+1+n) - tmp - 1; For(i,1,n) num[i]=lower_bound(tmp+1,tmp+1+len,num[i]) - tmp;}inline void init(int n){ dis(n); For(i,1,n){ uck[i]=i; ans[i]=1; up[i]=Up{num[i], num[i]}; }}int main(){ int T; Sca(T); while(T--){ int n; Sca(n); For(i,1,n){ int x; Sca(x); Sca(num[i]); tmp[i]=num[i]; } init(n); t.build(1,len,1); int m; Sca(m); while(m--){ char cmd[10]; scanf(\"%s\",cmd); if(cmd[0]=='r'){ int x,y; Sca2(x,y); x++; y++; merge(x,y); } else if(cmd[0]=='l'){ double x; scanf(\"%lf\",&amp;x); x+=0.5; x = lower_bound(tmp+1,tmp+1+len,x) - tmp; if(x==len+1) puts(\"0 0\"); else{ P out = t.getans(x,1); printf(\"%d %d\\n\",out.fi,out.se); } } } }}","link":"/2019/07/19/UVA11992/"},{"title":"POJ - 2777 Count Color 线段树+位运算","text":"Count ColorTime Limit: 1000MS Memory Limit: 65536KTotal Submissions: 55483 Accepted: 16628Description Chosen Problem Solving and Program design as an optional course, you are required to solve all kinds of problems. Here, we get a new problem. There is a very long board with length L centimeter, L is a positive integer, so we can evenly divide the board into L segments, and they are labeled by 1, 2, … L from left to right, each is 1 centimeter long. Now we have to color the board - one segment with only one color. We can do following two operations on the board: “C A B C” Color the board from segment A to segment B with color C. “P A B” Output the number of different colors painted between segment A and segment B (including). In our daily life, we have very few words to describe a color (red, green, blue, yellow…), so you may assume that the total number of different colors T is very small. To make it simple, we express the names of colors as color 1, color 2, … color T. At the beginning, the board was painted in color 1. Now the rest of problem is left to your.Input First line of input contains L (1 &lt;= L &lt;= 100000), T (1 &lt;= T &lt;= 30) and O (1 &lt;= O &lt;= 100000). Here O denotes the number of operations. Following O lines, each contains “C A B C” or “P A B” (here A, B, C are integers, and A may be larger than B) as an operation defined previously.Output Ouput results of the output operation in order, each line contains a number.Sample Input 2 2 4C 1 1 2P 1 2C 2 2 2P 1 2Sample Output 21 题意：可以理解为L为多少个气球，T代表有多少种颜色，O代表操作数。C命令是区间[A,B]的气球染成C颜色，P命令是查询区间[A,B]有多少不同的颜色。题解：一开始的时候是线段树维护大小为30的数组，明显被卡掉了。于是换了个思路，其实就是用二进制做，最大就是1&lt;&lt;L-1，而每一位二进制上代表存在，0代表不存在。于是就能很简单的用位运算进行实现，唯一的难点就是要想到二进制，幸好做这道题的前一天学的是状压dp。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define fi first#define se second#define MP make_pair#define P pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define Sca(x) scanf(\"%d\",&amp;x)#define Sca2(x,y) scanf(\"%d%d\",&amp;x,&amp;y)#define Sca3(x,y,z) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z)#define Scl(x) scanf(\"%lld\",&amp;x)#define Scl2(x,y) scanf(\"%lld%lld\",&amp;x,&amp;y)#define Scl3(x,y,z) scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;z)#define Pri(x) printf(\"%d\\n\",x)#define Prl(x) printf(\"%lld\\n\",x)#define For(i,x,y) for(int i=x;i&lt;=y;i++)#define _For(i,x,y) for(int i=x;i&gt;=y;i--)#define FAST_IO std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);#define ll long longconst int INF=0x3f3f3f3f;const ll INFL=0x3f3f3f3f3f3f3f3f;const double Pi = acos(-1.0);using namespace std;template &lt;class T&gt;void tomax(T&amp;a,T b){ a=max(a,b); } template &lt;class T&gt;void tomin(T&amp;a,T b){ a=min(a,b); }const int N=1e5+5;int T;int color;struct Segt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define MID (tree[p].l+tree[p].r)&gt;&gt;1 struct Tree{ int l,r; int have,lz; inline void init(int left,int right){ l=left; r=right; have=1; lz=0; } inline void updata(int who){ have=who; lz=who; } inline void lable(){ color|=have; } }tree[N&lt;&lt;2|1]; inline void pushdown(int p){ tree[p].have=tree[lc].have|tree[rc].have; } inline void pushup(int p){ tree[lc].updata(tree[p].lz); tree[rc].updata(tree[p].lz); tree[p].lz=0; } void build(int l,int r,int p){ tree[p].init(l,r); if(l==r) return ; int mid=MID; build(l,mid,lc); build(mid+1,r,rc); } void updata(int l,int r,int p,int who){ if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r){ tree[p].updata(who); return ; } if(tree[p].lz) pushup(p); int mid=MID; if(l&lt;=mid) updata(l,r,lc,who); if(r&gt;mid) updata(l,r,rc,who); pushdown(p); } void getans(int l,int r,int p){ if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r){ tree[p].lable(); return ; } if(tree[p].lz) pushup(p); int mid=MID; if(l&lt;=mid) getans(l,r,lc); if(r&gt;mid) getans(l,r,rc); return ; } }t;int main(){ int n,m; Sca3(n,T,m); t.build(1,n,1); while(m--){ char cmd; scanf(\" %c\",&amp;cmd); int A,B; Sca2(A,B); if(A&gt;B) swap(A,B); if(cmd=='C'){ int C; Sca(C); t.updata(A,B,1,1&lt;&lt;(C-1)); } else if(cmd=='P'){ color=0; t.getans(A,B,1); int sum=0; while(color){ if(color&amp;1) sum++; color&gt;&gt;=1; } Pri(sum); } } return 0;}","link":"/2019/07/19/POJ2777/"},{"title":"CodeForces - 12D Ball 线段树","text":"题意：emmmm，就是题目描述的女性很奇葩，她们去参加国王举办的舞会，而每个女士有B、I、R三种属性，如果她们得知舞会上存在一个比自身所有属性都要高，那么她就会选择跳楼。。。问有多少个要跳楼的女士。 题解：其实很简单，即按照B进行从大到小排序，然后线段树对比I大的区间进行查询最大值，如果最大值大于自身的R那么这位正在查询的女士选择跳楼。最后把这么女士的信息插入到线段树的I点给予R值，即查完再更新。然后查到最后，其中判断成功累积的值就是结果了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define fi first#define se second#define MP make_pair#define P pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define Sca(x) scanf(\"%d\",&amp;x)#define Sca2(x,y) scanf(\"%d%d\",&amp;x,&amp;y)#define Sca3(x,y,z) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z)#define Scl(x) scanf(\"%lld\",&amp;x)#define Scl2(x,y) scanf(\"%lld%lld\",&amp;x,&amp;y)#define Scl3(x,y,z) scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;z)#define Pri(x) printf(\"%d\\n\",x)#define Prl(x) printf(\"%lld\\n\",x)#define For(i,x,y) for(int i=x;i&lt;=y;i++)#define _For(i,x,y) for(int i=x;i&gt;=y;i--)#define FAST_IO std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);#define ll long longconst int INF=0x3f3f3f3f;const ll INFL=0x3f3f3f3f3f3f3f3f;const double Pi = acos(-1.0);using namespace std;template &lt;class T&gt;void tomax(T&amp;a,T b){ a=max(a,b); } template &lt;class T&gt;void tomin(T&amp;a,T b){ a=min(a,b); }const int N=5e5+5;struct Segt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define MID (tree[p].l+tree[p].r)&gt;&gt;1 struct Tree{ int l,r; int val; }tree[N&lt;&lt;2|1]; void pushdown(int p){ tree[p].val=max(tree[lc].val,tree[rc].val); } void build(int l,int r,int p){ tree[p]=Tree{l,r,0}; if(l==r) return ; int mid=MID; if(l&lt;=mid) build(l,mid,lc); if(r&gt;mid) build(mid+1,r,rc); } void updata(int pos,int p,int val){ if(tree[p].l==pos &amp;&amp; tree[p].r==pos){ tomax(tree[p].val,val); return ; } int mid=MID; if(pos&lt;=mid) updata(pos,lc,val); if(pos&gt;mid) updata(pos,rc,val); pushdown(p); } int getmax(int l,int r,int p){ if(l&gt;r) return 0; if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r) return tree[p].val; int maxx=0; int mid=MID; if(l&lt;=mid) tomax(maxx,getmax(l,r,lc)); if(r&gt;mid) tomax(maxx,getmax(l,r,rc)); return maxx; }}t;struct Data{ int a,b,c;}num[N];int tmp[N];bool cmp(Data one, Data tow){ return one.a &gt; tow.a; }int discrete(int n){ sort(tmp+1,tmp+1+n); return unique(tmp+1,tmp+1+n) - tmp;}int main(){ int n; Sca(n); For(i,1,n) Sca(num[i].a); For(i,1,n) { Sca(num[i].b); tmp[i]=num[i].b; } For(i,1,n) Sca(num[i].c); sort(num+1,num+1+n,cmp); int lenb = discrete(n) - 1; For(i,1,n) num[i].b=lower_bound(tmp+1,tmp+1+lenb,num[i].b) - tmp; int ans=0; t.build(1,lenb,1); int minn=num[1].a; int l=1;// For(i,1,n){// cout&lt;&lt;num[i].a&lt;&lt;' '&lt;&lt;num[i].b&lt;&lt;' '&lt;&lt;num[i].c&lt;&lt;endl;// } For(i,2,n){ if(num[i].a&lt;minn){ minn=num[i].a; For(j,l,i-1) t.updata(num[j].b,1,num[j].c); l=i; } if(t.getmax(num[i].b+1,lenb,1) &gt; num[i].c) ans++; } Pri(ans);}//9//7//7//7//5//2//1//1//1","link":"/2019/07/19/CodeForces12D/"}],"tags":[{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"并查集","slug":"并查集","link":"/tags/并查集/"},{"name":"模拟","slug":"模拟","link":"/tags/模拟/"},{"name":"位运算","slug":"位运算","link":"/tags/位运算/"}],"categories":[{"name":"ACM","slug":"ACM","link":"/categories/ACM/"}]}