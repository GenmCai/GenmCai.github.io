{"pages":[],"posts":[{"title":"CodeForces - 12D Ball 线段树","text":"题意：emmmm，就是题目描述的女性很奇葩，她们去参加国王举办的舞会，而每个女士有B、I、R三种属性，如果她们得知舞会上存在一个比自身所有属性都要高，那么她就会选择跳楼。。。问有多少个要跳楼的女士。 题解：其实很简单，即按照B进行从大到小排序，然后线段树对比I大的区间进行查询最大值，如果最大值大于自身的R那么这位正在查询的女士选择跳楼。最后把这么女士的信息插入到线段树的I点给予R值，即查完再更新。然后查到最后，其中判断成功累积的值就是结果了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define fi first#define se second#define MP make_pair#define P pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define Sca(x) scanf(\"%d\",&amp;x)#define Sca2(x,y) scanf(\"%d%d\",&amp;x,&amp;y)#define Sca3(x,y,z) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z)#define Scl(x) scanf(\"%lld\",&amp;x)#define Scl2(x,y) scanf(\"%lld%lld\",&amp;x,&amp;y)#define Scl3(x,y,z) scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;z)#define Pri(x) printf(\"%d\\n\",x)#define Prl(x) printf(\"%lld\\n\",x)#define For(i,x,y) for(int i=x;i&lt;=y;i++)#define _For(i,x,y) for(int i=x;i&gt;=y;i--)#define FAST_IO std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);#define ll long longconst int INF=0x3f3f3f3f;const ll INFL=0x3f3f3f3f3f3f3f3f;const double Pi = acos(-1.0);using namespace std;template &lt;class T&gt;void tomax(T&amp;a,T b){ a=max(a,b); } template &lt;class T&gt;void tomin(T&amp;a,T b){ a=min(a,b); }const int N=5e5+5;struct Segt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define MID (tree[p].l+tree[p].r)&gt;&gt;1 struct Tree{ int l,r; int val; }tree[N&lt;&lt;2|1]; void pushdown(int p){ tree[p].val=max(tree[lc].val,tree[rc].val); } void build(int l,int r,int p){ tree[p]=Tree{l,r,0}; if(l==r) return ; int mid=MID; if(l&lt;=mid) build(l,mid,lc); if(r&gt;mid) build(mid+1,r,rc); } void updata(int pos,int p,int val){ if(tree[p].l==pos &amp;&amp; tree[p].r==pos){ tomax(tree[p].val,val); return ; } int mid=MID; if(pos&lt;=mid) updata(pos,lc,val); if(pos&gt;mid) updata(pos,rc,val); pushdown(p); } int getmax(int l,int r,int p){ if(l&gt;r) return 0; if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r) return tree[p].val; int maxx=0; int mid=MID; if(l&lt;=mid) tomax(maxx,getmax(l,r,lc)); if(r&gt;mid) tomax(maxx,getmax(l,r,rc)); return maxx; }}t;struct Data{ int a,b,c;}num[N];int tmp[N];bool cmp(Data one, Data tow){ return one.a &gt; tow.a; }int discrete(int n){ sort(tmp+1,tmp+1+n); return unique(tmp+1,tmp+1+n) - tmp;}int main(){ int n; Sca(n); For(i,1,n) Sca(num[i].a); For(i,1,n) { Sca(num[i].b); tmp[i]=num[i].b; } For(i,1,n) Sca(num[i].c); sort(num+1,num+1+n,cmp); int lenb = discrete(n) - 1; For(i,1,n) num[i].b=lower_bound(tmp+1,tmp+1+lenb,num[i].b) - tmp; int ans=0; t.build(1,lenb,1); int minn=num[1].a; int l=1;// For(i,1,n){// cout&lt;&lt;num[i].a&lt;&lt;' '&lt;&lt;num[i].b&lt;&lt;' '&lt;&lt;num[i].c&lt;&lt;endl;// } For(i,2,n){ if(num[i].a&lt;minn){ minn=num[i].a; For(j,l,i-1) t.updata(num[j].b,1,num[j].c); l=i; } if(t.getmax(num[i].b+1,lenb,1) &gt; num[i].c) ans++; } Pri(ans);}//9//7//7//7//5//2//1//1//1","link":"/2019/07/19/CodeForces12D/"},{"title":"Git常用命令","text":"Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 —— 百度百科 PS：这篇博文相当于字典，方便查阅用。而如果想要重零开始学习Git的使用技巧，推荐去廖雪峰的官方网站上学习。还有就是，下面的$都是可以省略的。 基础操作命令$ git init可以通过这个命令把当前目录变成Git可以进行管理的仓库，会生成隐藏的.git文件。 $ git add file_name通过这个命令可以指定的要添加的当前目录中的文件，也可以使用git add .直接上传当前目录下所有的文件。 $ git commit -m ‘’正式提交之前git add所添加的文件，后面则是当前提交所要对自己或者他人说明的信息。比如说'v0.1版本'。 $ git status此命令可以查看仓库当前的状态，包括有哪些修改后的文件没有添加或者提交到仓库中。 $ git diff file_namediff即difference，顾名思义就是查看文件名所对应的文件有什么跟仓库中不同的敌方，显示格式则是Unix通用的diff格式。 $ git log很明显，就是查看当前git的使用日志，俗称历史记。这里面会提供历史的提交记录，在每条提交记录，会有版本回退所需的专属版本号。在后面显示的(HEAD -&gt; 分支名)即这个分支使用的是这条记录的版本。 $ git reflog这个命令记录了每一次的命令，所以版本回退后，忘记了版本号，可以使用这个命令进行查看。 $ cat file_name则是可以查看文件内的内容 $ git rm file_name如果文件管理器中的文件删除了，那么就真正的在版本库中删除，那么就需要这个命令，然后git commit即可，要注意的一点是，如果已经在文件管理器中删除了文件，那git add的效果跟git rm是一样的。 版本回退操作命令$ git reset –hard HEAD^这个命令的意思则是回退到上一个版本。举一反三，HEAD^^则是回到上上个版本。 $ git reset –hard 版本号如果使用了版本回退，那之前的版本就发现用git log无法进行查看，这时就可以使用之前记住的版本号进行回退，不需要全部的输入版本号，当然也不能只输入前几个数字。要让Git知道这个是唯一的，让他知道要找的是谁。 $ git checkout – file_name这个命令可以把file_name文件在工作区的修改全部的撤回，这里有两种情况：1、文件修改后没有放入暂存区，撤销修改后就回到跟版本库中一摸一样的状态。2、已经添加到暂存区，又做出了修改。撤销修改就回到了暂存区后的状态。即回到最近一次git commit或者git add时的状态。 $ git reset HEAD这个命令可以把file_name文件在工作区的修改全部的撤回。把暂存区中的修改回退到工作区，当单单使用HEAD时，就是表示时最新版本。 远程库操作命令$ git remote add origin HTTP_Path|SSH_Path这个命令则是让本地的git关联到远程库中，而其中的origin则是远程库的名字，也可以改成其他的。 $ git push -u origin 分支名则是把本地库中所有内容推送到远程库上。而git push实际上就就是是把当前分支推送到远程。而由于是第一次关联这个远程库，所以加上-u参数，可以让本地的分支跟远程的分支关联起来，在以后的推送或者拉取时就可以简化命令。 $ git clone HTTP_Path|SSH_Path这个命令则是把网上的远程库给克隆下来。 分支操作命令$ git branch查看分支，在前面标有*的是当前使用分支。 $ git branch 分支名创建分支。 $ git checkout 分支名切换分支。 $ git checkout -b 分支名创建+切换分支。 $ git merge 分支名合并某分支到当前分支。 $ git branch -d 分支名删除分支。","link":"/2019/08/07/Git_Cmd/"},{"title":"MySQL配置文件设置(三)","text":"MySQL配置文件◆ 在my.ini文件中，我们可以设置各种MySQL的配置，例如字符集、端口号、目录地址等等 mysqld 名称 作用 post 端口号 datadir 数据目录 default_authentication_plugin 密码认证插件 default-storage-engine 默认存储引擎 sql-mode 开启严格模式 log-output 用文件记录日志 general-log 关闭日志输出 general_log_file 日志文件名称 slow-query-log 开启慢查询日志 slow_query_long_file 漫查询日志文件名称 long_query_time 大于多少秒的执行SQL被记录在慢查询日志 long-error 错误日志名称 server-id 数据库ID lower_case_table_names 把表名转换成小写 secure-file-priv 导入导出数据的目录地址 max_connections 最大连接数","link":"/2019/08/14/MySqlConfig/"},{"title":"MySQL函数学习笔记","text":"MySQL函数（一）◆ 像编程语言利用函数封装业务功能一样，数据库也把一些复杂的功能封装到函数里，供使用者调用 数字函数（一） 函数 功能 用例 ABS 绝对值 ABS(-100) ROUND 四舍五入 ROUND(4.62) FLOOR 强制舍位到最近的整数 FLOOR(9.9) CEIL 强制进位到最近的整数 CEIL(3.2) POWER 幂函数 POWER(2,3) LOG 对数函数 LOG(7,3) LN 对数函数 LN(10) 数字函数（二） 函数 功能 用例 SQRT 开平方 SQRT(9) PI 圆周率 PI() SIN 三角函数 SIN(1) COS 三角函数 COS(1) TAN 三角函数 TAN(1) COT 三角函数 COT(1) RADIANS 角度转换弧度 RADIANS(30) DEGREES 弧度转换角度 DEGREES(1) MySQL函数（二）获取系统时间函数◆ NOW()函数能获得系统日期和时间，格式yyyy-MM-dd hh:mm:ss ◆ CURDATE()函数能获得当前系统日期，格式yyyy-MM-dd ◆ CURTIME()函数能获得当前系统时间，格式hh:mm:ss 日期格式化函数（一）◆ DATE_FORMAT()函数用于格式化日期，返回用户想要的日期格式 1DATE_FORMAT(日期,表达式) 12SELECT ename,DATE_FORMAT(hiredate,\"%Y\")FROM t_emp; 日期格式化函数（二） 占位符 作用 占位符 作用 %Y 年份 %m 日期 %d 日期 %w 星期（数字） %W 星期（名称） %j 本年第几天 %U 本年第几周 %H 小时（24） %h 小时（12） %i 分钟 %s 秒 %r 时间（24） %T 时间（12） 日期计算◆ MySQL数据库里面，两个日期不能直接加减，日期也不能与数字加减 ◆ DATE_ADD()函数可以实现日期的偏移计算，而且时间单位很灵活 1DATE_ADD(日期,INTERVAL 偏移量 时间单位) 例： 12SELECT DATE_ADD(NOW(),INTERVAL 15 DAY);SELECT DATE_ADD(NOW(),INTERVAL -300 MINUTE); ◆ DATEDIFF()函数用来计算两个日期之间相差的天数 1DATEDIFF(日期，日期) MySQL函数（三）字符函数（一） 函数 功能 用例 LOWER 转换小写字符 LOWER(ename) UPPER 转换大写字符 UPPER(ename) LENGTH 字符数量 LENGTH(ename) CONCAT 连接字符串 CONCAT(sal,”$”) INSTR 字符出现的位置 INSTR(ename,”A”) INSERT 插入/替换字符 INSERT(“你好”,1,0,”先生”) REPLACE 替换字符 REPLACE(“你好先生”,”先生”,”女士”) 字符函数（二） 函数 功能 用例 SUBSTR 截取字符串 SUBSTR(“你好世界”,3,4) SUBSTRING 截取字符串 SUBSTRING(“你好世界”,3,2) LPAD 左侧填充字符 LPAD(“Hello”,10,”*”) RPAD 右侧填充字符 RPAD(“Hello”,10,”*”) TRIM 去除首尾空格 TRIM(“ 你好先生 “) MySQL函数(四)◆ SQL语句中可以利用条件函数来实现变成语言里的条件判断 12IFNULL(表达式,值)IF(表达式,值1,值2) ◆ 复杂的条件判断可以用条件语句来实现，比IF语句功能更强大 123456CASE WHEN 表达式 THEN 值1 WHEN 表达式 THEN 值2 ...... ELSE 值NEND","link":"/2019/08/17/MySqlFunction/"},{"title":"MySQL数据操纵语言学习笔记（二）","text":"INSERT语句◆ INSERT语句可以向数据表写入记录，可以是一条记录，也可以是多条记录 12INSERT INTO 表名(字段1,字段2,......)VALUES (值1,值2，......); PS: 虽然INSERT语句可以不带字段名，但是不写字段名，MySql无法快速的写入。 12INSERT INTO 表名(字段1,字段2)VALUES(值1,值2,......),(值1,值2,......); 方言◆ MYSQL的INSERT语句还有一种方言语法 1INSERT INTO 表名 SET 字段1=值1,字段2=值2,......; IGNORE关键字◆ IGNORE关键字会让INSERT只插入数据库不存在的记录 1INSERT [IGNORE] INTO 表名......; 例: 12INSERT IGNORE INTO t_dept(deptno,dname,loc)VALUES(40,\"技术部\",\"北京\") UPDATE语句◆ UPDATE语句用于修改表的记录 123456UPDATE [IGNORE] 表名 # IGNORE遇到冲突的忽略SET 字段1=值1,字段2=值2,......[WHERE 条件1 ......] # 有无条件修改[ORDER BY ......] # 对数据排序，防止与不可重复约束的冲突[LIMIT ......]; # 取分页数据，只能写一个参数，也就是前几条记录# SET是最后执行的语句 UPDATE语句的表连接（一）◆ 因为相关子查询效率非常低，所以我们可以利用表连接的方式来改造UPDATE语句 12UPDATE 表1 JOIN 表2 ON 条件SET 字段1 = 值1,字段2 = 值2, ......; ◆ 表连接的UPDATE语句可以修改多张表的记录 UPDATE语句的表连接（二）◆ UPDATE语句的表连接可以演变成下面的样子 123UPDATE 表1,表2SET 字段1 = 值1,字段2 = 值2,......WHERE 连接条件; UPDATE语句的表连接（三）◆ UPDATE语句的表连接既可以是内连接，又可以是外连接 12UPDATE 表1 [LEFT|RIGHT] JOIN 表2 ON 条件 SET 字段1 = 值1,字段2 = 值2, ......; DELETE语句◆ DELETE语句用于删除记录，语法如下： 12345DELETE [IGNORE] FROM 表名[WHERE 条件1,条件2, .......][ORDER BY ......][LIMIT ......];# FROM -&gt; WHERE -&gt; ORDER BY -&gt; LIMIT ◆ DELETE语句无法删除子查询获取数据的表中的数据，但可以使用表连接来删除。 DELETE语句的表连接（一）◆ 因为相关子查询效率非常低，所以我们可以利用表连接的方式来改造DELETE语句 1234DELETE 表1, ...... FROM 表1 JOIN 表2 ON 条件[WHERE 条件1, 条件2, ......][ORDER BY ......][LIMIT ......]; DELETE语句的表连接（二）◆ DELETE语句的表连接既可以是内连接，又可以是外连接 1DELETE 表1, ...... FROM 表1[LEFT|RIGHT] JOIN 表2 ON 条件......; 快速删除数据表全部记录◆ DELETE语句是在事务机制下删除记录，删除记录之前，先把将要删除的数据保存到日志文件里，然后再删除记录。 ◆ TRUNCATE语句在事务机制之外删除记录，速度远超过DELETE语句 1TRUNCATE TABLE 表名;","link":"/2019/08/17/MySqlDML2/"},{"title":"MySQL数据库定义语言学习笔记","text":"数据库的范式◆ 构造数据库必须遵循一定得规则，这种规则就是范式。 ◆ 目前关系数据库有6中范式，一般情况下，只满足第三范式即可。 第一范式：原子性◆ 第一范式是数据库的基本要求，不满足这一点就不是关系数据库。 ◆ 数据表得每一列都是不可分割得基本数据项，同一列中不能有多个值，也不能存在重复的属性。 不符合第一范式： 学号 姓名 班级 1000 刘娜 高三年级1班 符合第一范式： 学号 姓名 年级 班级 1000 刘娜 高三 1班 第二范式：唯一性◆ 数据表中的每条记录必须是唯一的。为了实现区分，通常要为表加上一个列用于存储唯一标识，这个唯一属性列被称作主键列。 无法区分重复数据： 学号 考试成绩 日期 230 58 2018-07-15 230 58 2018-07-15 数据具有唯一性： 流水号 学号 考试成绩 日期 201807152687 230 58 2018-07-15 201807152694 230 58 2018-07-15 第三范式：关联性◆ 每列都与主键有直接关系，不存在传递依赖 违反第三范式： 爸爸 儿子 女儿 女儿的玩具 女儿的衣服 陈华 陈浩 陈婷婷 海绵宝宝 校服 符合第三范式： 爸爸 儿子 女儿 陈华 陈浩 陈婷婷 女儿 女儿的玩具 女儿的衣服 陈婷婷 海绵宝宝 校服 ◆ 依照第三范式，数据可以拆分保存到不同的数据表，彼此保持关联 编号 部门 电话 10 财务部 1001 20 技术部 1002 30 销售部 1003 编号 姓名 性别 部门 入职日期 1 陈浩 男 10 2018-05-10 2 李婷婷 女 30 2018-03-22 字段约束◆ MySQL中的字段约束共有四种： 约束名称 关键字 描述 主键约束 PRIMARY KEY 字段值唯一，且不能为NULL 非空约束 NOT NULL 字段值不能为NULL 唯一约束 UNIQUE 字段值唯一，且可以为NULL 外键约束 FOREIGN KEY 保持关联数据的逻辑性 主键约束◆ 主键约束要求字段的值在全表必须唯一，而且不能为NULL值 ◆ 建议主键一定要使用数字类型，因为数字的检索速度会非常块 ◆ 如果主键是数字类型，还可以设置自动增长 1234CREATE TABLE t_teacher( id INT PRIMARY KEY AUTO_INCREMENT, ......); 非空约束◆ 非空约束要求字段的值不能为NULL值 ◆ NULL值以为没有值，而不是 “” 空字符串 123456CREATE TABLE t_teacher( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(200) NOT NULL, married BOOLEAN NOT NULL DEFAULT FALSE);# 不能为空时，DEFAULT 默认值 唯一约束◆ 唯一约束要求字段值如果不为NULL，那么在全表必须唯一 1234CREATE TABLE t_teacher( ...... tel CHAR(11) NOT NULL UNIQUE); 外键约束◆ 外键约束用来保证关联数据的逻辑关系 父表： deptno dname tel 10 财务部 1001 20 技术部 1002 30 销售部 1003 子表： empno name sex deptno hiredate 1 陈浩 男 10 2018-05-10 2 李婷婷 女 30 2018-03-22 ◆ 外键约束的定义是写在子表上的 12345678910CREATE TABLE t_emp( empno INT UNSIGNED PRIMARY KEY, ename VARCHAR(20) NOT NULL, sex ENUM(\"男\", \"女\") NOT NULL, deptno INT UNSIGNED, hiredate DATE NOT NULL, FOREIGN KEY (deptno) REFERENCES t_dept(deptno));# ENUM()规定字段值，只能在规定的字段值之内挑选一个# FOREIGN KEY 规定外界约束 外建约束的闭环问题◆ 如果形成外键闭环，我们将无法删除任何一张表的记录。 PS: 所以创建数据表的时候不推荐使用外键约束。","link":"/2019/08/15/MySqlDDL1/"},{"title":"POJ - 2777 Count Color 线段树+位运算","text":"Count ColorTime Limit: 1000MS Memory Limit: 65536KTotal Submissions: 55483 Accepted: 16628Description Chosen Problem Solving and Program design as an optional course, you are required to solve all kinds of problems. Here, we get a new problem. There is a very long board with length L centimeter, L is a positive integer, so we can evenly divide the board into L segments, and they are labeled by 1, 2, … L from left to right, each is 1 centimeter long. Now we have to color the board - one segment with only one color. We can do following two operations on the board: “C A B C” Color the board from segment A to segment B with color C. “P A B” Output the number of different colors painted between segment A and segment B (including). In our daily life, we have very few words to describe a color (red, green, blue, yellow…), so you may assume that the total number of different colors T is very small. To make it simple, we express the names of colors as color 1, color 2, … color T. At the beginning, the board was painted in color 1. Now the rest of problem is left to your.Input First line of input contains L (1 &lt;= L &lt;= 100000), T (1 &lt;= T &lt;= 30) and O (1 &lt;= O &lt;= 100000). Here O denotes the number of operations. Following O lines, each contains “C A B C” or “P A B” (here A, B, C are integers, and A may be larger than B) as an operation defined previously.Output Ouput results of the output operation in order, each line contains a number.Sample Input 2 2 4C 1 1 2P 1 2C 2 2 2P 1 2Sample Output 21 题意：可以理解为L为多少个气球，T代表有多少种颜色，O代表操作数。C命令是区间[A,B]的气球染成C颜色，P命令是查询区间[A,B]有多少不同的颜色。题解：一开始的时候是线段树维护大小为30的数组，明显被卡掉了。于是换了个思路，其实就是用二进制做，最大就是1&lt;&lt;L-1，而每一位二进制上代表存在，0代表不存在。于是就能很简单的用位运算进行实现，唯一的难点就是要想到二进制，幸好做这道题的前一天学的是状压dp。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define fi first#define se second#define MP make_pair#define P pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define Sca(x) scanf(\"%d\",&amp;x)#define Sca2(x,y) scanf(\"%d%d\",&amp;x,&amp;y)#define Sca3(x,y,z) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z)#define Scl(x) scanf(\"%lld\",&amp;x)#define Scl2(x,y) scanf(\"%lld%lld\",&amp;x,&amp;y)#define Scl3(x,y,z) scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;z)#define Pri(x) printf(\"%d\\n\",x)#define Prl(x) printf(\"%lld\\n\",x)#define For(i,x,y) for(int i=x;i&lt;=y;i++)#define _For(i,x,y) for(int i=x;i&gt;=y;i--)#define FAST_IO std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);#define ll long longconst int INF=0x3f3f3f3f;const ll INFL=0x3f3f3f3f3f3f3f3f;const double Pi = acos(-1.0);using namespace std;template &lt;class T&gt;void tomax(T&amp;a,T b){ a=max(a,b); } template &lt;class T&gt;void tomin(T&amp;a,T b){ a=min(a,b); }const int N=1e5+5;int T;int color;struct Segt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define MID (tree[p].l+tree[p].r)&gt;&gt;1 struct Tree{ int l,r; int have,lz; inline void init(int left,int right){ l=left; r=right; have=1; lz=0; } inline void updata(int who){ have=who; lz=who; } inline void lable(){ color|=have; } }tree[N&lt;&lt;2|1]; inline void pushdown(int p){ tree[p].have=tree[lc].have|tree[rc].have; } inline void pushup(int p){ tree[lc].updata(tree[p].lz); tree[rc].updata(tree[p].lz); tree[p].lz=0; } void build(int l,int r,int p){ tree[p].init(l,r); if(l==r) return ; int mid=MID; build(l,mid,lc); build(mid+1,r,rc); } void updata(int l,int r,int p,int who){ if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r){ tree[p].updata(who); return ; } if(tree[p].lz) pushup(p); int mid=MID; if(l&lt;=mid) updata(l,r,lc,who); if(r&gt;mid) updata(l,r,rc,who); pushdown(p); } void getans(int l,int r,int p){ if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r){ tree[p].lable(); return ; } if(tree[p].lz) pushup(p); int mid=MID; if(l&lt;=mid) getans(l,r,lc); if(r&gt;mid) getans(l,r,rc); return ; } }t;int main(){ int n,m; Sca3(n,T,m); t.build(1,n,1); while(m--){ char cmd; scanf(\" %c\",&amp;cmd); int A,B; Sca2(A,B); if(A&gt;B) swap(A,B); if(cmd=='C'){ int C; Sca(C); t.updata(A,B,1,1&lt;&lt;(C-1)); } else if(cmd=='P'){ color=0; t.getans(A,B,1); int sum=0; while(color){ if(color&amp;1) sum++; color&gt;&gt;=1; } Pri(sum); } } return 0;}","link":"/2019/07/19/POJ2777/"},{"title":"MySql事务机制学习笔记（一）","text":"事务机制（一）避免写入直接操作数据文件◆ 如果数据的写入直接操作数据文件是非常危险的事情 利用日志来实现间接写入◆ MySQL总共有5种日志，其中只有redo日志和undo日志与事务有关 事务机制（Transaction）◆ RDBMS = SQL语句 + 事务（ACID） ◆ 事务是一个或者多个SQL语句组成的整体，要么全部执行成功，要么全部执行失败。 管理事务◆ 默认情况下 MySQL执行每条SQL语句都会自动开启和提交事务 ◆ 为了让多条SQL语句纳入到一个事务之下，可以手动管理事务 12345START TRANSACTION;SQL语句[COMMIT|ROLLBACK];# COMMIT 提交# ROLLBACK 回滚 事务的ACID属性原子性◆ 一个事务中的所有操作要么全部完成，要么全部失败。事务执行后，不允许停留在中间的某个状态 一致性◆ 不管在任何给定的时间、并发事务有多少，事务必须保证运行结果的一致性 隔离性◆ 隔离性要求事务不受其他并发事务的影响，如同在给定的时间内，该事务时数据可唯一运行的事务 持久性◆ 事务一旦提交，结果便是永久性的。即便发生宕机，仍然可以依靠事务日志完成数据的持久化 事务机制（二）事务的四个隔离级别 序号 隔离级别 功能 1 read uncommitted 读取未提交数据 2 read committed 读取已提交数据 3 repeatable read 重复读取 4 serializable 序列化 READ UNCOMMITTED◆ READ UNCOMMITTED 代表可以读取其他事务未提交的数据 1SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; READ COMMITTED◆ READ COMMITTED 代表只能读取其他事务提交的数据 1SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; REPEATABLE READ◆ REPEATABLE READ 代表事务在执行中反复读取数据，得到的结果是一致的，不会受其他事务影响。 1SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ; ◆ 这是MySQL默认的隔离级别 SERIALIZABLE◆ 由于事务并发执行所带来的各种问题，前三种隔离级别只使用在某些业务场景中，但是序列化的隔离性，让事务逐一执行，就不会产生上述问题了。 1SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE；","link":"/2019/08/19/MySql_TransactionMechanism/"},{"title":"Python-OS模块-DateTime模块","text":"标准模块——OS模块 函数/变量 描述 environ 包含环境变量的映射 system(command) 在子shell中执行操作系统命令 sep 路径中使用的分隔符 pathsep 分隔不用路径的分割符 linesep 行分隔符（’\\n’、’\\r’或’\\r\\n’） urandom(n) 返回n个字节的强加密随机数据 argv 命令行参数，包括脚本名 getcwd 放回当前所在的目录 modules 一个字典，将模块名映射到加载的模块 path 一个列表，包含要在其中查找模块的目录的名称 platform 一个平台标识符，如sunos5或win32 mkdir/rmdir 创建和删除文件夹 os.path 文件目录相关操作 os.getcwd() 目前位置 os.listdir() 当前位置有哪些文件 os.path.isdir(‘Name’) 是否是文件夹 os.path.isfile(‘Name’) 是否是文件 os.path.exists(‘Name’) 是否存在 os.path.dirname(‘Name’) 文件所在目录 os.path.split(‘Name’) 分为文件所在目录和文件的名称，返回类型为元组 os.path.splitext(‘Name’) 可将文件后缀分出，返回类型为元组 f = os.path.join(‘’,’’,’’) 路径拼接os.path.makedirs(f) 建立目录 标准模块——DateTime模块 函数/变量 描述 timedelta 对日期/时间进行加减操作时作用 date date类表示一个日期 datetime.strftime 将datetime对象格式化成字符串 datetime.strptime 将字符串按照一定的格式转换成datetime对象 time 表示一个时间的类 datetime.now 系统的当前时间 day Datetime对象的属性，类似的还有minute,hour等 days Timedelta的属性，类似的还有minutes,hours等 DateTime模块转换参数表 参数 含义 %A 星期的名称，如Monday %B 月份名，如January %m 用数字表示的月份(01~12) %d 用数字表示月份中的一天(01~31) %Y 四位的年份，如2015 %y 两位的年份，如15 %H 24小时制的小时数(00~23) %I 12小时制的小时数(01~12) %p am或pm %M 分钟数(00~59) %S 秒数(00~61)","link":"/2019/08/08/Py_Os_DateTime/"},{"title":"Python协程学习笔记","text":"协程◆ 协程就是协同多任务 ◆ 协程在一个进程或者是一个线程中执行 ◆ 不需要锁机制 ◆ 对多核CPU的利用——多进程+协程 协程的实现◆ python3.5以前 使用生成器（yield）来实现代码： 1234567891011121314151617def count_down(n): \"\"\" 倒计时效果 \"\"\" while n &gt; 0: yield n n -= 1def yield_test(): while True: n = (yield) print(n)if __name__ == '__main__': rest = yield_test() next(rest) rest.send('6666') ◆ python3.5以后 使用async和await关键字实现代码： 123456789101112131415161718192021import asyncioasync def do_sth(x): \"\"\" 定义协程函数 \"\"\" print('等待中：{0}'.format(x)) # 等待5秒，表现await作用 await asyncio.sleep(x)# 判断是否为协程函数print(asyncio.iscoroutinefunction(do_sth))coroutine = do_sth(5)# 事件的循环队列loop = asyncio.get_event_loop()# 注册任务task = loop.create_task(coroutine)print(task)# 等待协程任务执行结束loop.run_until_complete(task)print(task) asyncio模块◆ get_event_loop()获得事件循环队列 ◆ run_until_complete()注册任务到队列 ◆ 在事件循环中调度其执行前，协程对象不执行任何操作 ◆ asyncio模块用于事件循环 await 关键字◆ 等待协程执行完成 ◆ 当遇到阻塞调用的函数的时候，使用await方法将协程的控制权让出，以便loop调用其他的协程 协程之间的数据通信◆ 嵌套调用 代码： 123456789101112131415import asyncioasync def compute(x, y): print('计算 x + y =&gt; {0}+{1}'.format(x, y)) await asyncio.sleep(3) return x + yasync def get_sum(x, y): rest = await compute(x, y) print('{0} + {1} = {2}'.format(x, y, rest))# 拿到事件循环loop =asyncio.get_event_loop()loop.run_until_complete(get_sum(1, 2))loop.close() ◆ 队列 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 1. 定义一个队列# 2. 让两个协程进行通信# 3. 让其中一个协程往队列中写入数据# 4. 让另一个协程从队列中删除数据import asyncioimport randomasync def add(store, name): \"\"\" 写入数据到队列 :param store: 队列的对象 :return: \"\"\" for i in range(5): # 往队列中添加数字 num = '{0} - {1}'.format(name, i) await asyncio.sleep(random.randint(1, 5)) await store.put(i) print('{2} add one ... {0}, size：{1}'.format( num, store.qsize(), name))async def reduce(store): \"\"\" 从队列中删除数据 :param store: :return: \"\"\" for i in range(10): rest = await store.get() print(' reduce one.. {0}, size：{1}'.format(rest, store.qsize()))if __name__ == '__main__': # 准备一个对列 store = asyncio.Queue(maxsize=5) a1 = add(store, 'a1') a2 = add(store, 'a2') r1 = reduce(store) # 添加到事件队列 loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.gather(a1, a2, r1)) loop.close()","link":"/2019/08/13/Py_Coroutine_1/"},{"title":"MySQL数据的导入与导出","text":"数据的导入与导出数据导出与备份的区别◆ 数据导出，导出的纯粹是业务数据 ◆ 数据备份，备份的是数据文件、日志文件、索引文件等等 全量备份 -&gt; 增量备份1 -&gt;增量备份2 ◆ 数据导出的分类：SQL文档，文本文档 导出SQL文件◆ mysqldump用来把业务数据导出称SQL文件，其中也包括表结构 12mysqldump -uroot -p [no-data] 逻辑库 &gt; 路径# 写 no-data则表示只导出表结构 导入SQL文件◆ source命令用于导入SQL文件，包括创建数据表，写入记录等 12sql &gt; USE demo;sql &gt; SOURCE backup.sql; 例： 12345678# 到命令行中进行登陆mysql -uroot -p# 切换到demo的逻辑库里USE demo;# 找到文件路径SOURCE D:/data/demp.sql 建议用SQL文件来保存表结构，而txt文件来保存数据。因为txt文件没有SQL语句的执行，MySQL直接跳过词法分析和语法优化，直接把数据导入到文档里面，这样的导入十分的快速。 数据导出，导出的只是数据文件","link":"/2019/08/18/MySql_data_import_export/"},{"title":"Python多线程学习笔记","text":"进程 -&gt; 线程 -&gt; 协程 线程的介绍重要性◆ 跳槽、面试、决定薪资高度 ◆ 解决”效率”问题 ◆ Python的GIL导致的系列问题 ◆ 通常会混合使用（多进程 + 协程） 进程◆ 是一个执行中的程序 ◆ 每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据 ◆ 操作系统管理其上所有进程的执行，并为这些进程合理地分配时间 ◆ 进程也可通过派生（fork或者spawm）新的进程来执行其他任务 PS：fork在windows上的支持不是太好，代码只可能在Linux上运行的话，建议用fork。 线程◆ 在同一个进程下执行，并共享相同的上下文 ◆ 一个进程中的各个线程与主线程共享同一片数据空间 ◆ 线程包括开始、执行顺序和结束三部分 ◆ 它可以被抢占（中断）和临时挂起（也称为睡眠）——让步 ◆ 一般是以并发方式执行 并发◆ 不等同于并行处理 ◆ 是一种属性——程序、算法或问题的属性 ◆ 并行只是并发问题的可能方法之一 ◆ 如果两个事件互不影响，则两个事件是并发的 多核的利用及GIL概念对多核的利用◆ 单核CPU系统中，不存在真正的并发 ◆ GIL —— 全局解释器锁 ◆ GIL只是强制在任何时候只有一个线程可以执行Python代码 ◆ I/O密集型应用与CPU密集型应用 （架构师和后台开发需要对此有更深的了解） Python对I/O密集型应用会有比较强大的优势，在CPU密集型应用就发挥不出这样的优势了。而为了弥补CPU密集型应用的缺陷，可以进行C或者C++的扩展。 GIL执行顺序 设置GIL 切换进一个线程去运行 执行下面操作之一： ◆ 指定数量的字节码指令 ◆ 线程主动让出控制权（可以调用time.sleep(0)来完成） 把线程设置回睡眠状态（切换出线程） 解锁GIL 重复上述步骤","link":"/2019/08/11/Py_multithreading_1/"},{"title":"常用正则表达式","text":"正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 — 菜鸟教程 中文字符 [\\u4e00-\\u9fa5] PS：unicode编码 双字节字符（包括汉字在内） [^\\x00-\\xff] 空白行 \\n\\s*\\r Email地址 [\\w!#$%&amp;’+/=?^_`{|}~-]+(?:.[\\w!#$%&amp;’+/=?^_`{|}~-]+)@(?:[\\w](?:[\\w-][\\w])?.)+[\\w](?:[\\w-]*[\\w])? 网址URL [a-zA-z]+://[^\\s]* 国内电话号码 \\d{3}-\\d{8}|\\d{4}-{7,8} 腾讯QQ号 [1-9][0-9]{4,} 中国邮政编码 [1-9]\\d{5}(?!\\d) 18位身份证号 ^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$ （年-月-日）格式日期 ([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))) 正整数 ^[1-9]\\d*$ 负整数 ^-[1-9]\\d*$ 整数 ^-?[1-9]\\d*$ 非负整数（正整数 + 0） ^[1-9]\\d*|0$ 非正整数（负整数 + 0） ^-[1-9]\\d*|0$ 正浮点数 ^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 负浮点数 ^-[1-9]\\d.\\d|-0.\\d[1-9]\\d$ 在线正则表达式测试地址：http://tool.oschina.net/regex/#","link":"/2019/08/06/RE2/"},{"title":"What is SQL?","text":"SQL语言分类 DML(DATE Manipulation Language) 数据操纵语言1. 添加 2. 修改 3. 删除 4. 查询DCL (Date Control Language) 数据库控制语言1. 用户 2. 权限 3. 事务DDL (Date Definition Language) 数据库定义语言1. 逻辑库 2. 数据表 3. 视图 4. 索引 PS: 还有一个TCL(Transaction Control Language) 事务控制语言 SQL语句注意事项◆ SQL语句不区分大小写，但是字符串区分大小写 ◆ SQL语句必须以分号结尾 ◆ SQL语句中的空白和换行没有限制，但是不能破坏语法 SQL语句的注释◆ SQL语句的注释有两种，分别如下： 12# 这是一段注释文字/*这是另一段注释文字*/ 创建逻辑空间123CREATE DATABASE 逻辑库名称; # 不建议用中文SHOW DATABASES; # 显示有多少个逻辑空间;DROP DATABASE 逻辑库名称; # 删除逻辑空间 创建数据表12345CREATE TABLE 数据表( 列名1 数据类型 [约束] [COMMENT 注释], 列名2 数据类型 [约束] [COMMENT 注释], ......)[COMMENT = 注释]; PS: 中括号在这里表示可选 例： 123456789101112131415CREATE TABLE student( id INT UNSIGNED PRIMARY KEY, name VARCHAR(20) NOT NULL, sex CHAR(1) NOT NULL, birthday DATE NOT NULL, tel CHAR(11) NOT NULL, remark VARCHAR(200));# 说明：# PRIMARY KEY 主键，并且不允许重复# NOT NULL 不能为空# VARCHAR 不固定长度字符串# CHAR 固定长度字符串# UNSIGNED 无符号数字，也就是不允许有负数# DATE 时间类型 其他命令： 12345INSERT INTO student VALUES( ,...); # 向student数据表中插入数据SHOW tables; # 当前空间有哪些数据表DESC student; # 查看student表的具体情况SHOW CREATE TABLE student; # 查看数据表创建时的SQL语句DROP TABLE student; # 删除数据表","link":"/2019/08/14/whatSql/"},{"title":"CodeForces - 12D Ball 线段树","text":"题目意思就是，road命令连接第A坐标和第B坐标的点。而line则是查看纵坐标C拉出的扫描线过几个联通块，而联通块中的数量和是多少。（具体的可以查看原题） 题解：其实是线段树一个简单的模拟，即并查集找联通块和联通块中点的数量，然后每次更新删除A点和B点的信息，重新建立A点和B点连接后的信息就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define fi first#define se second#define MP make_pair#define P pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define Sca(x) scanf(\"%d\",&amp;x)#define Sca2(x,y) scanf(\"%d%d\",&amp;x,&amp;y)#define Sca3(x,y,z) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z)#define Scl(x) scanf(\"%lld\",&amp;x)#define Scl2(x,y) scanf(\"%lld%lld\",&amp;x,&amp;y)#define Scl3(x,y,z) scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;z)#define Pri(x) printf(\"%d\\n\",x)#define Prl(x) printf(\"%lld\\n\",x)#define For(i,x,y) for(int i=x;i&lt;=y;i++)#define _For(i,x,y) for(int i=x;i&gt;=y;i--)#define FAST_IO std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);#define ll long longconst int INF=0x3f3f3f3f;const ll INFL=0x3f3f3f3f3f3f3f3f;const double Pi = acos(-1.0);using namespace std;template &lt;class T&gt;void tomax(T&amp;a,T b){ a=max(a,b); } template &lt;class T&gt;void tomin(T&amp;a,T b){ a=min(a,b); }const int N=1e5+5;struct Segt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define MID (tree[p].l+tree[p].r)&gt;&gt;1 struct Tree{ int l,r; int uck,val,lz[2]; inline void init(int left,int right){ l=left; r=right; uck=0; val=0; lz[0]=0; lz[1]=0; } void updata(int uckv,int valv){ uck+=uckv; val+=valv; lz[0]+=uckv; lz[1]+=valv; } }tree[N&lt;&lt;2|1]; void pushdown(int p){ tree[p].uck=tree[lc].uck+tree[rc].uck; tree[p].val=tree[lc].val+tree[rc].val; } void pushup(int p){ int one=tree[p].lz[0],two=tree[p].lz[1]; tree[lc].updata(one,two); tree[rc].updata(one,two); tree[p].lz[0]=0; tree[p].lz[1]=0; } void build(int l,int r,int p){ tree[p]=Tree{l,r,0,0,0,0}; if(l==r) return ; int mid=MID; build(l,mid,lc); build(mid+1,r,rc); } void updata(int l,int r,int p,int uckv,int valv){ if(l&gt;r) return ; if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r){ tree[p].updata(uckv,valv); return ; } if(tree[p].lz[0] || tree[p].lz[1]) pushup(p); int mid=MID; if(l&lt;=mid) updata(l,r,lc,uckv,valv); if(r&gt;mid) updata(l,r,rc,uckv,valv); pushdown(p); } P getans(int pos,int p){ if(tree[p].l==pos &amp;&amp; tree[p].r==pos) return MP(tree[p].uck,tree[p].val); if(tree[p].lz[0] || tree[p].lz[1]) pushup(p); int mid=MID; if(pos&lt;=mid) return getans(pos, lc); if(pos&gt;mid) return getans(pos, rc); }}t;struct Up{ int minn,maxx; } up[N];int num[N],tmp[N],uck[N],ans[N];int len=0;int find(int x){ return uck[x]==x ? x : uck[x]=find(uck[x]); }void merge(int x,int y){ int t1(find(x)),t2(find(y)); if(t1!=t2){ t.updata(up[t1].minn+1,up[t1].maxx,1,-1,-ans[t1]); t.updata(up[t2].minn+1,up[t2].maxx,1,-1,-ans[t2]); uck[t2]=t1; ans[t1]+=ans[t2]; tomax(up[t1].maxx,up[t2].maxx); tomin(up[t1].minn,up[t2].minn); t.updata(up[t1].minn+1,up[t1].maxx,1,1,ans[t1]); }}inline void dis(int n){ sort(tmp+1,tmp+1+n); len=unique(tmp+1,tmp+1+n) - tmp - 1; For(i,1,n) num[i]=lower_bound(tmp+1,tmp+1+len,num[i]) - tmp;}inline void init(int n){ dis(n); For(i,1,n){ uck[i]=i; ans[i]=1; up[i]=Up{num[i], num[i]}; }}int main(){ int T; Sca(T); while(T--){ int n; Sca(n); For(i,1,n){ int x; Sca(x); Sca(num[i]); tmp[i]=num[i]; } init(n); t.build(1,len,1); int m; Sca(m); while(m--){ char cmd[10]; scanf(\"%s\",cmd); if(cmd[0]=='r'){ int x,y; Sca2(x,y); x++; y++; merge(x,y); } else if(cmd[0]=='l'){ double x; scanf(\"%lf\",&amp;x); x+=0.5; x = lower_bound(tmp+1,tmp+1+len,x) - tmp; if(x==len+1) puts(\"0 0\"); else{ P out = t.getans(x,1); printf(\"%d %d\\n\",out.fi,out.se); } } } }}","link":"/2019/07/19/UVA11992/"},{"title":"正则表达式(RegEx)集合（初级）","text":"正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式中的符号 table th:first-of-type { width: 110px; } table th:nth-of-type(3) { width: 135px } 符号 描述 示例 str 匹配文本字符串的字面值str abc str1|str2 匹配正则表达式str1|str2 abc|bca . 匹配任何字符（除\\n） abc.abc ^ 匹配字符串起始部分 ^Dear $ 匹配字符串终止部分 /str1/*str2$ * 匹配0次或者多次前面出现的正则表达式 [A-Za-z0-9]* + 匹配1次或者多次前面出现的正则表达式 [a-z]+\\.com ? 匹配0次或者1次前面出现的正则表达式 str? {N} 匹配N次前面出现的正则表达式 [A-Z]{3} {M,N} 匹配M到N次（包括M和N）前面出现的正则表达式 [0,9]{3,6} […] 匹配括号中说明的字符集的任意单一字符 [abc] […x-y…] 匹配x-y范围中的任意单一字符 [A-Za-z0-9] [^…] 不匹配此字符集中出现的任何一个字符，包括某一范围的字符（如果在此字符集中出现） [^aedv],[^A-Z] (*|+|?|{})? 用于匹配上面频繁出现/重复出现符号的非贪婪版本（*、+、?、{}） .*?[A-Z] (…) 匹配封闭的正则表达式，然后另存为子组 (A(B(C))) 正则表达式中的特殊字符 特殊字符 描述 示例 \\d 匹配任何十进制数字，与[0-9]一致(\\D与\\d相反，不匹配任何十进制数字) f\\d.txt \\w 匹配任何字母数字字符，与[A-Za-z0-9]相同（\\W与之相反） [A-Za-z]\\w+ \\s 匹配任何空格字符，与[\\n\\t\\r\\v\\f]相同(\\S与之相反) of\\sthe \\b 匹配任何单词边界（\\B与之相反） \\bThe\\b \\N 匹配已保存的子组N（参见上面的(…)） price:\\16 \\c 逐字匹配任何特殊字符c（即，仅按照字面意义匹配，不匹配特殊含义） \\.,\\\\,\\* \\A(\\Z) 匹配字符串的起始(结束)（如上面介绍的^和$） \\ADear 正则表达式中的扩展表示法 (?str)在正则表达式中嵌入一个或者多个特殊“标记”参数（或者通过函数/方法） (?:…)表示一个匹配不用保存的分组 (?P&lt;name&gt;)向一个仅由name标识而不是数字ID标识的正则分组匹配 (?P=name)在同一字符串中匹配由(?P)分组的之前文本 (?#…)表示注释，所有内容都被忽略 (?=…)匹配条件是如果…出现在之后的位置，而不使用输入字符串；称作正向前视断言 (?!…)匹配条件是如果…不出现在之后的位置，而不使用输入字符串；称作负向前视断言 (?&lt;=…)匹配条件是如果…出现在之前的位置，而不使用输入字符串；称作正向后视断言 (?&lt;!…)匹配条件是如果…不出现在之前的位置，而不是用输入字符串；称作负向后视断言 (?(id/name)Y|N)如果分组所提供的id或者name（名称）存在，就返回正则表达式的条件匹配Y，如果不存在，就返回N；|N是可选项（也就是说是可省略的）。ps: 有点像C++中的三目运算符 贪婪模式vs非贪婪模式〇 贪婪模式 在整个表达式匹配成功的前提下，尽可能多的匹配 〇 非贪婪模式 在整个表达式匹配成功的前提下，尽可能少的匹配 默认是贪婪模式","link":"/2019/08/05/RE1/"},{"title":"Hexo 绑定个人域名（华为云版）","text":"个人使用的hexo主题是伊卡洛斯(icarus)，虽然应该对下面的操作没有影响，但姑且还是说一下好了。域名控制管理平台是华为云 1.购买域名(华为云版) 1、进入华为云域名注册https://www.huaweicloud.com/product/domain.html，搜索自己喜欢的域名。 2、选择自己喜欢的域名（建议选择常见的，比如说：com，cn，net之类的，考虑到兼容性的问题），然后进行购买。 3、选择好要购买的期限和域名信息模板（没有的自己建一个，里面的要填写的信息没有特别要讲究的）。 Node:要注意的就是域名购买后，域名信息要实名认证成功后，购买的域名才可以被解析（通俗的说：能被使用） 2、绑定域名 前提是域名到账户上，并且成功实名认证后 1、进入华为云控制台，在华为云服务搜索框中搜素 云解析服务 DNS，然后进入。 2、一般来说是在公网解析中，在里面可以看到你购买成功的域名，然后点击解析，不用管其它的，直接点击进行设置。填入信息后，确定即可添加成功。 table th:first-of-type { width: 100px; } 填写目录 填写信息 主机记录 旁边有个问号，里面有详解，我是直接填了www 类型 普通的只需要A、CNAME（详情的可以看后面的跟的说明），我选择的是CNAME 别名 不用管，没用到，选否 线路类型 普通的全网默认就行了 TTL 默认，5分钟 值 CNAME： 填写需要绑定的域名（例：genmcai.github.io） A： 填写需要绑定的IP（查看方法放下面） 权重 可选参数，解析记录的权重，可选参数，默认值为1。取值范围：0~100。当域名有多条某一类型的解析记录时，根据权重数值选择解析记录，权重数值越高，优先级越高 IP查看方法Ctrl+R 进入 运行 输入 cmd ，输入命令 Ping 域名(例：Ping genmcai.github.io) 下面出现的IPv4地址即是 A 所需的值 3、进入github，到存放网站的仓库，Settings -&gt; Options -&gt; GitHub Pages -&gt; Custom domain -&gt; 填写需要绑定的个人域名 点击save后，网站上会提示是否成功，如果失败并且自己解决不了，可以在下面留言，我看到后会尽力帮你解决。 4、最后一步，在hexo的根目录下source 中添加一个无后缀名的文件（文件名：CNAME），里面内容填写个人域名(例：www.genmcai.com，至于有些同学会问怎么写入，这个可以直接先txt填入内容后删掉后缀名，或者用VS code之类的打开无后缀名的文件，也能写入。 这一步可以说挺重要的，如果没有这个文件，hexo g -d提交后，页面就会变成404，这个时候重复第3个步骤就能恢复，不过每次都这样很麻烦，而且可能会清空博客访问记录。 至此，个人域名的绑定就结束了，重新使用自己的个人域名进行访问，就能访问到绑定的hexo了。如果出现错误，有可能是主题版本的原因，也有可能是其他的原因。欢迎有疑问的小伙伴在下面留言。","link":"/2019/08/03/hexo_DomainName/"},{"title":"MySQL数据操纵语言学习笔记（一）","text":"记录查询◆ 最基本的查询语句是由SELECT和FROM 关键字组成的 12SELECT * FROM t_emp;SELECT empno,ename,sal FROM t_emp; ◆ SELECT语句屏蔽了物理层的操作，用户不必关心数据的真是存储，交由数据库高效的查找数据 使用列别名◆ 通常情况下，SELECT子句中使用了表达式，那么这列的名字就默认为表达式，因此需要一种对列名重命名的机制 1234SELECT empno, sal*12 AS \"income\"FROM t_emp; 数据分页◆ 比如我们查看朋友圈，只会加载少量部分信息，不用一次性加载全部朋友圈，那样只会浪费CPU时间、内存和网络宽带 ◆ 如果结果集的记录很多，则可以使用LIMIT关键字限定结果集数量。 1SELECT ...... FROM ...... LIMIT 起始位置，偏移量; 例子： 1SELECT empno,ename FROM t_emp LIMIT 0,20; ◆ 如果LIMIT子句只有一个参数，它表示的是偏移量，起始值默认为0 123SELECT empno,ename FROM t_emp LIMIT 10;SELECT empno,ename FROM t_emp LIMIT 0,10;# 执行顺序 FROM -&gt; SELECT -&gt; LIMIT 结果集排序◆ 如果没有设置，查询语句不会对结果集进行排序。也就是说，如果想让结果集按照某种顺序排列，就必须使用ORDER BY子句。 1SELECT ...... FROM ...... ORDER BY 列名 [ASC|DESC]; 例： 12SELECT ename,sal FROM t_emp ORDER BY sal;# 默认为ASC ◆ ASC代表升序（默认），DESC代表降序 ◆ 如果排序列是数字类型，数据库就按照数字大小排序，如果是日期类型就按照日期大小排序，如果是字符串就按照字符集序号排序 ◆ 我们可以使用ORDER BY规定首要排序条件和次要排序条件。数据库会先按照首要排序条件排序，如果遇到首要排序内容相同的记录，那么就会启用次要排序条件接着排序 ◆ ORDER BY子句书写的时候放在LIMIT子句的前面 FROM -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT 去除重复记录◆ 加入我们要查询员工表有多少种职业，写出来的SQL语句如下： SELECT job FROM t_emp; ◆ 如果我们需要去除重复的数据，可以使用DISTINCT关键字来实现 1SELECT DISTINCT 字段 FROM ......; 例： 1SELECT DISTINCT job FROM t_emp; ◆ 使用DISTINCT的SELECT子句中只能查询一列数据，如果查询多列，去除重复记录就会失效 1SELECT DISTINCT job,ename FROM t_emp; ◆ DISTINCT关键字只能在SELECT子句中使用一次 12SELECT DISTINCT job,DISTINCT ename FROM t_emp;SELECT ename,DISTINCT job FROM t_emp; 条件查询◆ 很多时候，用户感兴趣的并不是逻辑表中的全部记录，而只是它们当中能够满足某一种或几种条件的记录。这类条件要用WHERE子句来实现数据的筛选 1SELECT ...... FROM ...... WHERE 条件[AND|OR] 条件 ...... 例： 12SELECT empno,ename,sal FROM t_empWHERE deptno=10 AND sal &gt;= 2000; ◆ 不管怎么样的数字和null做加减乘除运算都是null ◆ 如果想要让null值参与运算的话，可以使用IFNULL(字段的名称或NULL都可以,值) 12SELECT 10+IFNULL(NULL,0);# NULL当成0来运算 ◆ DATEDIFF(NOW(),hiredate) 第一个日期减去第二个日期，求相差多少天 ◆ 比较运算符中的表达式IN,是包含的意义。如：deptno IN(10,30,40) 比较运算符（部分）: 表达式 意义 例子 IS NULL 为空 comm IS NULL IS NOT NULL 不为空 comm IS NOT NULL BETWEEN AND 范围 sal BETWEEN 2000 AND 3000 LIKE 模糊查询 ename LIKE”A%” REGEXP 正则表达式 ename REGEXP “[a-zA-Z]{4}” 逻辑运算符： AND,OR,NOT,XOR 按位运算符： &amp;,|,~,^,&lt;&lt;,&gt;&gt; ◆ WHERE子句中，条件执行的顺序是从左到右的。所以我们应该把索引条件，或者筛选掉记录最多的条件写在最左侧 ◆ FROM -&gt; WHERE -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT 聚合函数◆ 聚合函数在数据的查询分析中，应用十分广泛。聚合函数可以对数据求和、求最大值和最小值、求平均值等等。 例： 12SELECT AVG(sal+INNULL(comm,0)) FROM t_emp;# 可以取别名，缩短字段名的长度 ◆ SUM函数用于求和，只能用于数字类型，字符类型的统计结果为0，日期类型统计结果是毫秒数相加。 ◆ MAX函数用于获得非空值的最大值。 12SELECT MAX(LENGTH(ename)) FROM t_emp;# LENGTH()取字符串长度 ◆ MIN函数用于获得非空值的最小值 ◆ AVG函数用于获得非空值的平均值，非数字数据统计结果为0 ◆ COUNT(*)用于获得包含空值的记录数，COUNT(列名)用于获得包含非空值的记录数。 12SELECT COUNT(*) FROM t_emp;SELECT COUNT(comm) FROM t_emp; 分组查询◆ 默认情况下汇总函数是对全表范围内的数据做统计 ◆ GROUP BY子句的作用是通过一定的规则将一个数据集划分成若干个小的区域，然后针对每个小区域分别进行数据汇总处理 12SELECT deptno,AVG(sal) FROM t_empGROUP BY deptno; ◆ 数据库支持多列分组条件，执行的时候逐级分组 123SELECT deptno,job,COUNT(*),AVG(sal)FROM t_emp GROUP BY deptno,jobORDER BY deptno; ◆ 查询语句中如果含有GROUP BY子句，那么SELECT子句中的内容就必须要遵守规定：SELECT子句中可以包括聚合函数，或者GROUP BY子句的分组列，其余内容均不可以出现在SELECT子句中 ◆ WITH ROLLUP对汇总函数再次执行汇总计算 123SELECT deptno,AVG(sal),SUM(sal),MAX(sal),MIN(sal),COUNT(*)FROM t_empGROUP BY deptno WITH ROLLUP; ◆ GROUP_CONCAT函数可以把分组查询中的某个字段拼接成一个字符串 123SELECT deptno,GROUP_COUNT(ename),COUNT(*)FROM t_emp WHERE sal&gt;=2000GROUP BY deptno; ◆ FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT HAVING◆ 必须配合GROUP BY子句进行使用，用法近乎于WHERE，为分组后的条件查询 ◆ 按照数字1分组，MySQL会一句SELECT子句中的列进行分组，HAVING子句也可以正常使用 123SELECT deptno,COUNT(*) FROM t_empGROUP BY 1 HAVING deptno IN (10,20);# 不建议替代WHERE的功能 表连接◆ 从多张表中提取数据，必须指定关联的条件。如果不定义关联条件，就会出现无条件连接，两张表的数据会交叉连接，产生笛卡儿积。 ◆ 规定了连接条件的表连接语句，就不会出现笛卡儿积 123SELECT e.empno,e.ename,d.dnameFROM t_emp e JOIN t_dept dON e.deptno=d.deptno; ◆ 表连接分为两种：内连接和外连接 ◆ 内连接是结果集中只保留符合连接条件的记录 ◆ 外连接是不管符不符合连接条件，记录都要保留在结果集中 内连接◆ 内连接是最常见的一种表连接，用于查询多张关系表符合连接条件的记录。 123456SELECT ...... FROM 表1[INNER] JOIN 表2 ON 条件{INNER} JOIN 表3 ON 条件SELECT ...... FROM 表1 JOIN 表2 ON 连接条件;SELECT ...... FROM 表1 JOIN 表2 WHERE 连接条件；SELECT ...... FROM 表1，表2 WHERE 连接条件； 低效率： 1234SELECT enameFROM t_empWHERE deptno=(SELECT deptno FROM t_emp WHERE ename=\"SCOTT\")AND ename!=\"SCOTT\"; 高效率： 123SELECT e2.enameFROM t_emp e1 JOIN t_emp e2 ON e1.deptno=e2.deptnoWHERE e1.ename=\"SCOTT\" AND e2.ename!=\"SCOTT\"; 1234SELECTFROM t_emp e JOIN(SELECT deptno,AVG(sal) AS avg FROM t_emp GROUP BY deptno) tON e.deptno=t.deptno; ◆ MySQL存在FLOOR()和CELL()用法 外连接◆ 外连接与内连接的区别在于，除了符合条件的记录之外，结果集中还会保留不符合条件的记录 12345SELECT e.empno,e.ename,d.dnameFROM t_emp eLEFT JOIN t_dept d ON e.deptno = d.deptno; ◆ 左外连接就是保留左表所有的记录，与右表做连接。如果右表有符合条件的记录就与左表连接。如果右表没有符合条件的记录，就用NULL与左表连接。右外连接也是如此。 右连接： 123SELECT e.empno,e.ename,d.dnameFROM t_dept d RIGHT JOIN t_emp eON e.deptno = d.deptno; ◆ 内连接只保留符合条件的记录，所以查询条件卸载ON子句和WHERE子句中的效果是相同的。但是外连接里，条件写在WHERE子句里，不符合条件的记录是会被过滤掉的，而不是保留下来。 123456SELECT e.ename,d.dname,d.deptnoFROM t_emp eLEFT JOIN t_dept d ON e.deptno = d.deptnoWHERE e.deptno = 10; 子查询◆ 子查询是一种查询中嵌套查询的语句 ◆ 子查询可以写在三个地方：WHERE子句、FROM子句、SELECT子句，但是只有FROM子句子查询是最可取的 WHERE子拆线呢◆ 这种子查询最简单，最容易理解，但是却是效率很低的子查询 12345SELECT empno,ename,salFROM t_empWHERE sal&gt;=(SELECT AVG(sal) FROM t_emp);# 比较每条记录都要重新执行子查询 FROM子查询◆ 这种子查询只会执行一次，所以查询效率很高 123456SELECT e.empno,e.ename,e.sal,t.avgFROM t_emp e JOIN (SELECT deptno,AVG(sal) as avg) FROM t_emp GROUP BY deptno) tON e.deptno=t,deptno AND e.sal&gt;=t.avg; SELECT子查询◆ 这种子查询每输出一条记录的时候都要执行一次，查询效率很低 12345SELECT e.empno, e.ename, (SELECT dename FROM t_dept WHERE deptno=e.deptno)FROM t_emp e; 单行子查询和多行子查询◆ 单行子查询的结果集只有一条记录，多行子查询结果集有多行记录 ◆ 多行子查询只能出现在WHERE子句和FROM子句中 ◆ WHERE子句中，可以使用IN、ALL、ANY、EXISTS关键字来处理多行表达式结果集的条件判断 123456SELECT ename FROM t_empWHERE sal &gt; ALL(SELECT sal FROM t_empWHERE ename IN(\"FORD\",\"MARTIN\"));# ALL必须比结果集中的记录都要高# ANY只要比结果集中的一条记录高就行了 ◆ EXISTS关键字是把原来在子查询之外的条件判断，写到了子查询里面 1SELECT ...... FROM 表名 WHERE [NOT] EXISTS (子查询);","link":"/2019/08/16/MySqlDML1/"},{"title":"Python内存管理机制","text":"赋值语句内存分析◆ 使用id()方法访问内存地址 ◆ 使用is比较内存引用地址是否相等 在python之中，像数值、字符串、布尔型单纯的赋值，它们只要值相等，那么对应的变量名所在的地址也是相等的，而这就是python对内存管理的优化。相对的，如：[]列表的复制，其所对应的地址却是不同的。 代码： 123456789101112131415def extend_list(val, l=[]): print('---------------------') print(l, id(l)) l.append(val) print(l, id(l)) return llist1 = extend_list(10)list2 = extend_list(123, [])list3 = extend_list('a')print(list1)print(list2)print(list3) 输出如下: 123456789101112---------------------[] 1976185016904[10] 1976185016904---------------------[] 1976215339528[123] 1976215339528---------------------[10] 1976185016904[10, &apos;a&apos;] 1976185016904[10, &apos;a&apos;][123][10, &apos;a&apos;] 结论：对比list1、list2、list3的输出结果后，就能了解在函数中默认的列表，其在python的内存存储机制。list2不同的原因，就在于它使用的是新生成的列表，而list1和list3相同的原因，则是它们使用的是函数中默认的列表，在内存中，它们是同一个。 垃圾回收机制◆ 以引用计数为主，分代收集为辅 ◆ 如果一个对象的引用数为0，Python虚拟机就会回收这个对象的内存 ◆ 引用计数的缺陷是循环引用的问题 代码（1）： 12345678910111213class Cat(object): def __init__(self): print('对象产生了：{0}'.format(id(self))) def __del__(self): print('对象删除了：{0}'.format(id(self)))def f0(): while True: c1 = Cat()if __name__ == '__main__': f0() 输出如下： 12345678对象产生了：1775928937992对象删除了：1775928938312对象产生了：1775928938312对象删除了：1775928937992对象产生了：1775928937992对象删除了：1775928938312对象产生了：1775928938312对象删除了：1775928937992 代码（2）： 1234567891011121314151617class Cat(object): def __init__(self): print('对象产生了：{0}'.format(id(self))) def __del__(self): print('对象删除了：{0}'.format(id(self)))def f1(): l = [] while True: c1 = Cat() l.append(c1) print('列表元素：', len(l), '个')if __name__ == '__main__': f1() 输出如下： 12345678910对象产生了：1627687778248列表元素： 88839 个对象产生了：1627687778312列表元素： 88840 个对象产生了：1627687778376列表元素： 88841 个对象产生了：1627687778440列表元素： 88842 个对象产生了：1627687778504列表元素： 88843 个 结论：对上面两个代码和输出结果对比，能发现。第一个代码因为后续没有再对之前的生成进行使用，所以虽然不是立刻删除，但也是会马上的进行删除，这样，内存的使用空间不会一直的增长。相对的，第二个代码，它把生成的对象存放到了列表之中，这个列表对之前生成的所有对象进行了引用，所以其存在就不会被删除，内存空间早晚会溢出。 引用计数（reference count）◆ 每个对象都存有指向该对象的引用总数 ◆ 查看某个对象的引用计数 sys.getrefcount() ◆ 可以使用del关键词删除某个引用 代码： 12345678910111213141516171819import sysi = 1s = []l2 = sl3 = sl5 = l3print(sys.getrefcount(s))del l2#对象l被引用的数量print(sys.getrefcount(s))print('------------------')print(sys.getrefcount(i))c = iprint(sys.getrefcount(i)) 输出如下： 1234554------------------9697 结论：可以很明显的看出，引用数不一定是从1开始，这涉及到python当中的内存共享的机制。而每一次的直接引用或者间接引用都会使引用数增加，而对s的引用次数的观察，可发现多了1，这是因为当我们输出的时候，也会对其进行引用，所以引用次数会多一次。 垃圾回收◆ 满足特定条件，自动启动垃圾回收 ◆ 当Python运行时，会记录其中分配对象（object allocation）和取消分配对象（object deallocation）的次数 ◆ 当两者的差值高于某个阈(yù)值时，垃圾回收才会启动 ◆ 查看阈值gc.get_threshold() gc — Garbage Collector interface 代码： 123import gcprint(gc.get_threshold()) 输出如下： 1(700, 10, 10) 分代回收◆ Python将所有的对象分为0，1，2三代 ◆ 所有的新建对象都是0代对象 ◆ 当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象 PS：即初始为0代，每次回收不掉，就对其进行代数的提升，最高为2代。而其有阈值存在，当0代回收次数到达一定的阈值，才会回收1代，而1代回收到一定的阈值，才会回收2代。而1代和2代的回收，会把前面的回收再执行。 手动回收◆ gc.collect()手动回收 ◆ objgraph模块中的count()记录当前类产生的实例对象的个数 代码（1）: 123456789101112131415161718192021222324252627import gc, sysimport objgraphprint(gc.get_threshold())class Persion(object): passclass Cat(object): passp = Persion()c = Cat()p.name = 'Susan'p.pet = cc.master = pprint(sys.getrefcount(p))print(sys.getrefcount(c))del pdel c# 手动执行垃圾回收gc.collect()print(objgraph.count('Persion'))print(objgraph.count('Cat')) 输出如下： 12345(700, 10, 10)3300 代码（2）： 123# 上面代码注释掉这两行代码# del p# del c 输出如下： 12345(700, 10, 10)3311 结论：如果不进行手动回收，那么就会导致回收不掉的。 内存管理机制◆ 内存池(memory pool)机制 当创建大量消耗小内存的对象时，频繁调用new/malloc会导致大量的内存碎片，致使效率降低。内存池的概念就是预先再内存中申请一定数量的，大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。 ◆ Python3中的内存管理机制——Pymalloc 针对小对象（&lt;=512bytes），pymalloc会在内存池中申请内存空间 当&gt;512bytes，则会PyMem_RawMalloc()和PyMem_RawRealloc()来申请新的内存空间 ◆ 单位换算1 Byte = 8 Bit （即 1B = 8b）1 KB = 1024 Bytes1 MB = 1024 KB1 GB = 1024 MB1 TB = 1024 GB1 PB = 1024 TB1 EB = 1024 PB1 ZB = 1024 EB1 YB = 1024 ZBPS：Bit意为”位”或”比特”，时计算机运算的基础，属于二进制的范畴；Byte意为”字节”，时计算机文件大小的基础计算单位。 结论 慕课网 时间_记录昨天 ： 从三方面来说：引用计数、垃圾回收机制、内存池机制。可以根据一下描述进行理解 一、对象的引用计数机制 Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。 引用计数增加的情况： 1、一个对象分配一个新名称 2、将其放入一个容器中（如列表、元组或字典） 引用计数减少的情况： 1、使用del语句对对象别名显示的销毁 2、引用超出作用域或被重新赋值 sys.getrefcount( )函数可以获得对象的当前引用计数 多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。 二、垃圾回收 1、当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。 2、当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。 三、内存池机制 1、Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。 2、Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。 3、Python中所有小于256个字节的对象都是用pymalloc实现的分配器，而大的对象则使用系统的malloc，另外Python对象比如整数浮点数和list都有独立的私有内存池，对象间不共享他们的内存池，也就是说你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。","link":"/2019/08/10/Py_Mem_1/"},{"title":"Python进程学习笔记","text":"进程◆ 是一个执行中的程序 ◆ 每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据 ◆ 操作系统管理其上所有进程的执行，并为这些进程合理地分配时间 ◆ 进成也可通过派生（fork 或 spawn）新的进程来执行其他任务 PS：fork在windows上的支持不是太好，代码只可能在Linux上运行的话，建议用fork。 进程模块◆ 使用multiprocessing实现多进程代码 ◆ 用multiprocessing.Process创建进程 ◆ start()启动进程 ◆ join()挂起进程 ◆ os.getpid()获得进程的ID 进程的实现函数实现：123456789101112131415161718192021import os, timefrom multiprocessing import Processdef do_sth(name): \"\"\" 进程要做的事情 :param name: str 进程的名称 :return: \"\"\" print('进程名称：{0}， pid：{1}'.format(name, os.getpid())) time.sleep(150) print('进程要做的事情')if __name__ == '__main__': p = Process(target=do_sth, args=('my process', )) # 启动进程 p.start() # 挂起进程 p.join() 面向对象实现：123456789101112131415161718192021import os, timefrom multiprocessing import Processclass MyProcess(Process): def __init__(self, name, *args, **kwargs): super().__init__(*args, **kwargs) self.my_name = name def run(self): print('MyProcess进程的名称：{0}，pid: {1}'.format(self.my_name, os.getpid())) time.sleep(150) print('MyProcess进程要做的事情')if __name__ == '__main__': p = MyProcess('my process class') # 启动进程 p.start() # 挂起进程 p.join() 可以在任务管理器中找到对应的进程。 进程之间的通信◆ 通过Queue、Pipes等实现进程之间的通信 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import timefrom multiprocessing import Process, Queue, current_processimport randomimport timeclass WriteProcess(Process): \"\"\" 写的进程 \"\"\" def __init__(self, q, *args, **kwargs): super().__init__(*args, **kwargs) self.q = q def run(self): \"\"\" 实现进程的业务逻辑 \"\"\" # 要写的内容 ls = [ \"第1行内容\", \"第2行内容\", \"第3行内容\", \"第4行内容\", ] for line in ls: print('写入内容：{0} - {1}'.format(line, current_process().name)) self.q.put(line) # 每写入一次，休息1-5秒 time.sleep(random.randint(1, 5))class ReadProcess(Process): \"\"\" 读取内容进程 \"\"\" def __init__(self, q, *args, **kwargs): super().__init__(*args, **kwargs) self.q = q def run(self): while True: content = self.q.get() print('读取到的内容：{0} - {1}'.format(content, self.name))if __name__ == '__main__': # 通过Queue共享数据 q = Queue() # 写入内容的进程 t_write = WriteProcess(q) t_write.start() # 读取进程启动 t_read = ReadProcess(q) t_read.start() t_write.join() # t_read.join() # 因为读的进程是死循环，无法等待其结束，只能强制终止 t_read.terminate() 即使用数据对象进行通信 多进程中的锁◆ Lock() ◆ Rlock() ◆ Condition() PS：进程的锁是为了防止共享数据产生错误，从而加锁保证每次操作数据只有一个进程，且牺牲了多进程的并行执行效率。 Lock()代码： 1234567891011121314151617181920212223242526272829303132333435363738394041import randomimport timefrom multiprocessing import Process, Lockclass WriteProcess(Process): \"\"\" 写入文件 \"\"\" def __init__(self, file_name, num, lock, *args, **kwargs): # 文件的名称 super().__init__(*args, **kwargs) self.file_name = file_name self.num = num # 锁对象 self.lock = lock def run(self): \"\"\" 写入文件的主要业务逻辑 \"\"\" try: # 添加锁 self.lock.acquire() for i in range(5): content = '现在是：{0} : {1} - {2}\\n'.format( self.name, self.pid, self.num ) with open(self.file_name, 'a+', encoding='utf-8') as f: f.write(content) time.sleep(random.randint(1,5)) print(content) finally: self.lock.release()if __name__ == '__main__': file_name = 'test.txt' # 锁的对象 lock = Lock() for x in range(5): p = WriteProcess(file_name, x, lock) p.start() Rlock()代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import randomimport timefrom multiprocessing import Process, RLockclass WriteProcess(Process): \"\"\" 写入文件 \"\"\" def __init__(self, file_name, num, rlock, *args, **kwargs): # 文件的名称 super().__init__(*args, **kwargs) self.file_name = file_name self.num = num # 锁对象 self.rlock = rlock def run(self): \"\"\" 写入文件的主要业务逻辑 \"\"\" try: # 添加锁 self.rlock.acquire() print('locked') self.rlock.acquire() print('relocked') for i in range(5): content = '现在是：{0} : {1} - {2}\\n'.format( self.name, self.pid, self.num ) with open(self.file_name, 'a+', encoding='utf-8') as f: f.write(content) time.sleep(random.randint(1,5)) print(content) finally: self.rlock.release() self.rlock.release()if __name__ == '__main__': file_name = 'test.txt' # 锁的对象 rlock = RLock() for x in range(5): p = WriteProcess(file_name, x, rlock) p.start() RLock可重复锁，而Lock能重复锁，反而会导致死锁，导致程序无法正常运行，同线程的锁，有共同之处。 同样，可以使用with进行锁的添加和释放。 使用进程池同步添加任务代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import randomimport timefrom multiprocessing import Process, RLockclass WriteProcess(Process): \"\"\" 写入文件 \"\"\" def __init__(self, file_name, num, rlock, *args, **kwargs): # 文件的名称 super().__init__(*args, **kwargs) self.file_name = file_name self.num = num # 锁对象 self.rlock = rlock def run(self): \"\"\" 写入文件的主要业务逻辑 \"\"\" try: # 添加锁 self.rlock.acquire() print('locked') self.rlock.acquire() print('relocked') for i in range(5): content = '现在是：{0} : {1} - {2}\\n'.format( self.name, self.pid, self.num ) with open(self.file_name, 'a+', encoding='utf-8') as f: f.write(content) time.sleep(random.randint(1,5)) print(content) finally: self.rlock.release() self.rlock.release()if __name__ == '__main__': file_name = 'test.txt' # 锁的对象 rlock = RLock() for x in range(5): p = WriteProcess(file_name, x, rlock) p.start() 异步添加任务代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import randomimport timefrom multiprocessing import current_process, Pooldef run(file_name, num): \"\"\" 进程执行的业务逻辑 往文件中写入数据 :param file_name: str 文件名称 :param num: int 写入的数字 :return: str 写入的结果 \"\"\" with open(file_name, 'a+', encoding='utf-8') as f: # 当前的进程 now_process = current_process() # 写入的内容 content = '{0} - {1} - {2}'.format( now_process.name, now_process.pid, num ) f.write(content) f.write('\\n') # 写完之后随机休息1-5秒 time.sleep(random.randint(1, 5)) print(content) return 'ok'if __name__ == '__main__': file_name = 'test_pool.txt' # 进程池 pool = Pool(2) rest_list = [] for i in range(20): # 异步添加任务 rest = pool.apply_async(run, args=(file_name, i)) rest_list.append(rest) print('{0} --- {1}'.format(i ,rest)) # 关闭池子 pool.close() pool.join() # 查看异步执行的结果 print(rest_list[0].get()) PS：如果要用进程池的话，最好是用函数的方法实现，面向对象的方法相对的会比较麻烦。","link":"/2019/08/13/Py_process_1/"},{"title":"Python线程学习笔记","text":"实现一个线程◆ 用threading模块代替thread模块 ◆ 用threading.Tread创建线程 ◆ start()启动线程 ◆ join()挂起线程 threading 模块的对象 对象 描述 Thread 表示一个执行线程的对象 Lock 锁原语对象（和thread模块中的锁一样） RLock 可重入锁对象，使单一线程可以（再次）获得已持有的锁（递归锁） Condition 条件变量对象，使得一个线程等待另一个线程满足特定的”条件”，比如改变状态或某个数据值 Event 条件变量的通用版本，任意数量的线程等待某个事件的发生，在该事件发生后所有线程将被激活 Semaphore 为线程间共享的有限资源提供了一个”计数器”，如果没有可用资源时会被阻塞 BoundedSemaphore 与Semaphore相似，不过它不允许超过初始值 Timer 与Thread相似，不过它不允许超过初始值 Barrier 创建一个”障碍”，必须达到指定数量的线程后才可以继续 Thread 对象数据属性 属性 描述 name 线程名 ident 线程的标识符 daemon 布尔标志，表示这个线程是否是守护线程 Thread 对象方法 属性 描述 init() 实例化一个进程对象，需要有一个可以调用的target，以及其参数args或kwargs。 start() 开始执行该线程 run() 定义线程功能的方法（通常在子类中被应用开发者重写） join(timeout=None) 直至启动的线程终止之前一直挂起；除非给出了timeout(秒)，否者会一直阻塞 getName() 返回线程名 setName(name) 设定线程名 isAlivel/is_alive() 布尔标志，表示这个线程是否还存活 isDaemon() 如果是守护线程，则返回True;否则，返回False setDaemon() 把线程的守护标志设定为布尔值daemonic（必须在线程start()之前调用） 代码： 123456789101112131415161718192021222324252627282930import threadingimport timedef loop(): \"\"\" 新的线程执行的代码 \"\"\" now_thread = threading.current_thread() print('[loop]now thread name: {0}'.format(now_thread.name)) n = 0 while n &lt; 5: print(n) time.sleep(1) n += 1def use_thread(): \"\"\" 使用线程来实现 \"\"\" # 当前正在执行的线程名称 now_thread = threading.current_thread() print('now thread name：{0}'.format(now_thread.name)) #设置线程 t = threading.Thread(target=loop, name='loop_thread') # 启动线程 t.start() # 挂起线程 t.join()if __name__ == '__main__': use_thread() 输出如下： 1234567now thread name：MainThread[loop]now thread name: loop_thread01234 观察上面的代码和其输出可以发现，本来是由主线程进行的运行，经过新设置的线程后，变成由新线程进行运行 类形式代码： 123456789101112131415161718192021import threadingimport timeclass LoopThread(threading.Thread): \"\"\" 自定义线程 \"\"\" n = 0 def run(self): while self.n &lt; 5: print(self.n) now_thread = threading.current_thread() print('[loop]now thread name: {0}'.format(now_thread.name)) time.sleep(1) self.n += 1if __name__ == '__main__': t = LoopThread(name='loop_thread_oop') t.start() t.join() 实现多个线程代码如下： 123456789101112131415161718192021222324252627282930313233343536373839import threading# 我的银行账户import timebalance = 0def change_it(n): \"\"\" 改变我的余额 \"\"\" global balance balance = balance + n time.sleep(2) balance = balance - n time.sleep(1) print('-N---&gt; {0}; balance：{1}'.format(n, balance))class ChangeBalanceThread(threading.Thread): \"\"\" 改变银行余额的线程 \"\"\" def __init__(self, num, *args, **kwargs): super().__init__(*args, **kwargs) self.num = num def run(self): for i in range(1000000): change_it(self.num)if __name__ == '__main__': t1 = ChangeBalanceThread(5) t2 = ChangeBalanceThread(8) t1.start() t2.start() t1.join() t2.join() print('the last: {0}'.format(balance)) 输出如下： 123456789-N---&gt; 5; balance：0-N---&gt; 8; balance：5-N---&gt; 5; balance：0-N---&gt; 8; balance：5-N---&gt; 5; balance：0-N---&gt; 8; balance：5-N---&gt; 5; balance：0-N---&gt; 8; balance：5...... PS: global是全局变量的声明，为了让范围比我大的别人用我的东西，使用的时候要和作用域关联起来。 多线程中的锁实现 ◆ Lock() ◆ Rlock() ◆ Condition() Lock()代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import threadingimport time# 获得一把锁my_lock = threading.Lock()# 我的银行账户balance = 0def change_it(n): \"\"\" 改变我的余额 \"\"\" global balance try: # 添加锁 my_lock.acquire() balance = balance + n time.sleep(2) balance = balance - n time.sleep(1) print('-N---&gt; {0}; balance：{1}'.format(n, balance)) finally: # 释放掉锁 my_lock.release()class ChangeBalanceThread(threading.Thread): \"\"\" 改变银行余额的线程 \"\"\" def __init__(self, num, *args, **kwargs): super().__init__(*args, **kwargs) self.num = num def run(self): for i in range(1000000): change_it(self.num)if __name__ == '__main__': t1 = ChangeBalanceThread(5) t2 = ChangeBalanceThread(8) t1.start() t2.start() t1.join() t2.join() print('the last: {0}'.format(balance)) 输出如下： 12345678-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0...... 添加： 1234# 添加锁my_lock.acquire()# 资源已经被锁住了，不能重复锁定，产生死锁my_lock.acquire() 资源已经被锁住了，不能重复锁定，产生死锁 RLock()代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import threadingimport time# 获得一把锁your_lock = threading.RLock()# 我的银行账户balance = 0def change_it(n): \"\"\" 改变我的余额 \"\"\" global balance try: # 添加锁 your_lock.acquire() # 资源已经被锁住了，不能重复锁定，产生死锁 your_lock.acquire() balance = balance + n time.sleep(2) balance = balance - n time.sleep(1) print('-N---&gt; {0}; balance：{1}'.format(n, balance)) finally: # 释放掉锁 your_lock.release() your_lock.release()class ChangeBalanceThread(threading.Thread): \"\"\" 改变银行余额的线程 \"\"\" def __init__(self, num, *args, **kwargs): super().__init__(*args, **kwargs) self.num = num def run(self): for i in range(1000000): change_it(self.num)if __name__ == '__main__': t1 = ChangeBalanceThread(5) t2 = ChangeBalanceThread(8) t1.start() t2.start() t1.join() t2.join() print('the last: {0}'.format(balance)) 输出如下： 12345678-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0-N---&gt; 5; balance：0...... 在一个线程中锁住，还能再锁。 对锁使用的优化（自动释放，效率会变慢，但安全性提升）： 123456with your_lock: balance = balance + n time.sleep(2) balance = balance - n time.sleep(1) print('-N---&gt; {0}; balance：{1}'.format(n, balance)) 线程的调度和优化 我们的电脑和服务器是有限制的，线程是有上限的，不会无限制的暴力使用，所以在这里就需要进行优化，于是就有了内存池的概念。即建立一个池，当其中的线程完成自己的任务后，让其继续完成池子中未完成的任务，而不是直接销毁掉。 下面使用两种线程的调度和优化的方法 使用multiprocessing模块代码： 123456789101112131415161718192021222324import timeimport threadingfrom multiprocessing.dummy import Pooldef run(n): \"\"\" 线程要做的事情 \"\"\" time.sleep(2) print(threading.current_thread().name, n) def main_use_pool(): \"\"\" 使用线程池来优化 \"\"\" t1 = time.time() n_list = range(100) pool = Pool(10) pool.map(run, n_list) pool.close() pool.join() print(time.time() - t1)if __name__ == '__main__': main_use_pool() 输出如下： 12345678······Thread-6 91Thread-3 94Thread-8 97Thread-6 92Thread-3 95Thread-8 9824.017276763916016 PS: multiprocessing模块中有dummy.pool()和pool.Pool,前者是给线程用的，后者是给进程用的。 使用ThreadPoolExecutor类代码： 12345678910111213141516171819202122import timeimport threadingfrom concurrent.futures.thread import ThreadPoolExecutordef run(n): \"\"\" 线程要做的事情 \"\"\" time.sleep(2) print(threading.current_thread().name, n)def main_use_executor(): \"\"\" 使用 ThreadPoolExecutor 来优化\"\"\" t1 = time.time() n_list = range(100) with ThreadPoolExecutor(max_workers=10) as executor: executor.map(run, n_list) print(time.time() - t1)if __name__ == '__main__': main_use_executor() 输出如下： 123456789······ThreadPoolExecutor-0_4 93ThreadPoolExecutor-0_1 92ThreadPoolExecutor-0_6 95ThreadPoolExecutor-0_3 97ThreadPoolExecutor-0_8 98ThreadPoolExecutor-0_5 96ThreadPoolExecutor-0_7 9920.01082682609558 对比两种方法的运行的时间，确实ThreadPoolExecutor效率相对比较高一些","link":"/2019/08/12/Py_thread_1/"}],"tags":[{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"位运算","slug":"位运算","link":"/tags/位运算/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/正则表达式/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"并查集","slug":"并查集","link":"/tags/并查集/"},{"name":"模拟","slug":"模拟","link":"/tags/模拟/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"内存管理","slug":"内存管理","link":"/tags/内存管理/"}],"categories":[{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"正则表达式","slug":"正则表达式","link":"/categories/正则表达式/"},{"name":"SQL","slug":"SQL","link":"/categories/SQL/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"}]}