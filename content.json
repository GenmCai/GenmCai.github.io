{"pages":[],"posts":[{"title":"CodeForces - 12D Ball 线段树","text":"题意：emmmm，就是题目描述的女性很奇葩，她们去参加国王举办的舞会，而每个女士有B、I、R三种属性，如果她们得知舞会上存在一个比自身所有属性都要高，那么她就会选择跳楼。。。问有多少个要跳楼的女士。 题解：其实很简单，即按照B进行从大到小排序，然后线段树对比I大的区间进行查询最大值，如果最大值大于自身的R那么这位正在查询的女士选择跳楼。最后把这么女士的信息插入到线段树的I点给予R值，即查完再更新。然后查到最后，其中判断成功累积的值就是结果了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define fi first#define se second#define MP make_pair#define P pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define Sca(x) scanf(\"%d\",&amp;x)#define Sca2(x,y) scanf(\"%d%d\",&amp;x,&amp;y)#define Sca3(x,y,z) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z)#define Scl(x) scanf(\"%lld\",&amp;x)#define Scl2(x,y) scanf(\"%lld%lld\",&amp;x,&amp;y)#define Scl3(x,y,z) scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;z)#define Pri(x) printf(\"%d\\n\",x)#define Prl(x) printf(\"%lld\\n\",x)#define For(i,x,y) for(int i=x;i&lt;=y;i++)#define _For(i,x,y) for(int i=x;i&gt;=y;i--)#define FAST_IO std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);#define ll long longconst int INF=0x3f3f3f3f;const ll INFL=0x3f3f3f3f3f3f3f3f;const double Pi = acos(-1.0);using namespace std;template &lt;class T&gt;void tomax(T&amp;a,T b){ a=max(a,b); } template &lt;class T&gt;void tomin(T&amp;a,T b){ a=min(a,b); }const int N=5e5+5;struct Segt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define MID (tree[p].l+tree[p].r)&gt;&gt;1 struct Tree{ int l,r; int val; }tree[N&lt;&lt;2|1]; void pushdown(int p){ tree[p].val=max(tree[lc].val,tree[rc].val); } void build(int l,int r,int p){ tree[p]=Tree{l,r,0}; if(l==r) return ; int mid=MID; if(l&lt;=mid) build(l,mid,lc); if(r&gt;mid) build(mid+1,r,rc); } void updata(int pos,int p,int val){ if(tree[p].l==pos &amp;&amp; tree[p].r==pos){ tomax(tree[p].val,val); return ; } int mid=MID; if(pos&lt;=mid) updata(pos,lc,val); if(pos&gt;mid) updata(pos,rc,val); pushdown(p); } int getmax(int l,int r,int p){ if(l&gt;r) return 0; if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r) return tree[p].val; int maxx=0; int mid=MID; if(l&lt;=mid) tomax(maxx,getmax(l,r,lc)); if(r&gt;mid) tomax(maxx,getmax(l,r,rc)); return maxx; }}t;struct Data{ int a,b,c;}num[N];int tmp[N];bool cmp(Data one, Data tow){ return one.a &gt; tow.a; }int discrete(int n){ sort(tmp+1,tmp+1+n); return unique(tmp+1,tmp+1+n) - tmp;}int main(){ int n; Sca(n); For(i,1,n) Sca(num[i].a); For(i,1,n) { Sca(num[i].b); tmp[i]=num[i].b; } For(i,1,n) Sca(num[i].c); sort(num+1,num+1+n,cmp); int lenb = discrete(n) - 1; For(i,1,n) num[i].b=lower_bound(tmp+1,tmp+1+lenb,num[i].b) - tmp; int ans=0; t.build(1,lenb,1); int minn=num[1].a; int l=1;// For(i,1,n){// cout&lt;&lt;num[i].a&lt;&lt;' '&lt;&lt;num[i].b&lt;&lt;' '&lt;&lt;num[i].c&lt;&lt;endl;// } For(i,2,n){ if(num[i].a&lt;minn){ minn=num[i].a; For(j,l,i-1) t.updata(num[j].b,1,num[j].c); l=i; } if(t.getmax(num[i].b+1,lenb,1) &gt; num[i].c) ans++; } Pri(ans);}//9//7//7//7//5//2//1//1//1","link":"/2019/07/19/CodeForces12D/"},{"title":"POJ - 2777 Count Color 线段树+位运算","text":"Count ColorTime Limit: 1000MS Memory Limit: 65536KTotal Submissions: 55483 Accepted: 16628Description Chosen Problem Solving and Program design as an optional course, you are required to solve all kinds of problems. Here, we get a new problem. There is a very long board with length L centimeter, L is a positive integer, so we can evenly divide the board into L segments, and they are labeled by 1, 2, … L from left to right, each is 1 centimeter long. Now we have to color the board - one segment with only one color. We can do following two operations on the board: “C A B C” Color the board from segment A to segment B with color C. “P A B” Output the number of different colors painted between segment A and segment B (including). In our daily life, we have very few words to describe a color (red, green, blue, yellow…), so you may assume that the total number of different colors T is very small. To make it simple, we express the names of colors as color 1, color 2, … color T. At the beginning, the board was painted in color 1. Now the rest of problem is left to your.Input First line of input contains L (1 &lt;= L &lt;= 100000), T (1 &lt;= T &lt;= 30) and O (1 &lt;= O &lt;= 100000). Here O denotes the number of operations. Following O lines, each contains “C A B C” or “P A B” (here A, B, C are integers, and A may be larger than B) as an operation defined previously.Output Ouput results of the output operation in order, each line contains a number.Sample Input 2 2 4C 1 1 2P 1 2C 2 2 2P 1 2Sample Output 21 题意：可以理解为L为多少个气球，T代表有多少种颜色，O代表操作数。C命令是区间[A,B]的气球染成C颜色，P命令是查询区间[A,B]有多少不同的颜色。题解：一开始的时候是线段树维护大小为30的数组，明显被卡掉了。于是换了个思路，其实就是用二进制做，最大就是1&lt;&lt;L-1，而每一位二进制上代表存在，0代表不存在。于是就能很简单的用位运算进行实现，唯一的难点就是要想到二进制，幸好做这道题的前一天学的是状压dp。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define fi first#define se second#define MP make_pair#define P pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define Sca(x) scanf(\"%d\",&amp;x)#define Sca2(x,y) scanf(\"%d%d\",&amp;x,&amp;y)#define Sca3(x,y,z) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z)#define Scl(x) scanf(\"%lld\",&amp;x)#define Scl2(x,y) scanf(\"%lld%lld\",&amp;x,&amp;y)#define Scl3(x,y,z) scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;z)#define Pri(x) printf(\"%d\\n\",x)#define Prl(x) printf(\"%lld\\n\",x)#define For(i,x,y) for(int i=x;i&lt;=y;i++)#define _For(i,x,y) for(int i=x;i&gt;=y;i--)#define FAST_IO std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);#define ll long longconst int INF=0x3f3f3f3f;const ll INFL=0x3f3f3f3f3f3f3f3f;const double Pi = acos(-1.0);using namespace std;template &lt;class T&gt;void tomax(T&amp;a,T b){ a=max(a,b); } template &lt;class T&gt;void tomin(T&amp;a,T b){ a=min(a,b); }const int N=1e5+5;int T;int color;struct Segt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define MID (tree[p].l+tree[p].r)&gt;&gt;1 struct Tree{ int l,r; int have,lz; inline void init(int left,int right){ l=left; r=right; have=1; lz=0; } inline void updata(int who){ have=who; lz=who; } inline void lable(){ color|=have; } }tree[N&lt;&lt;2|1]; inline void pushdown(int p){ tree[p].have=tree[lc].have|tree[rc].have; } inline void pushup(int p){ tree[lc].updata(tree[p].lz); tree[rc].updata(tree[p].lz); tree[p].lz=0; } void build(int l,int r,int p){ tree[p].init(l,r); if(l==r) return ; int mid=MID; build(l,mid,lc); build(mid+1,r,rc); } void updata(int l,int r,int p,int who){ if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r){ tree[p].updata(who); return ; } if(tree[p].lz) pushup(p); int mid=MID; if(l&lt;=mid) updata(l,r,lc,who); if(r&gt;mid) updata(l,r,rc,who); pushdown(p); } void getans(int l,int r,int p){ if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r){ tree[p].lable(); return ; } if(tree[p].lz) pushup(p); int mid=MID; if(l&lt;=mid) getans(l,r,lc); if(r&gt;mid) getans(l,r,rc); return ; } }t;int main(){ int n,m; Sca3(n,T,m); t.build(1,n,1); while(m--){ char cmd; scanf(\" %c\",&amp;cmd); int A,B; Sca2(A,B); if(A&gt;B) swap(A,B); if(cmd=='C'){ int C; Sca(C); t.updata(A,B,1,1&lt;&lt;(C-1)); } else if(cmd=='P'){ color=0; t.getans(A,B,1); int sum=0; while(color){ if(color&amp;1) sum++; color&gt;&gt;=1; } Pri(sum); } } return 0;}","link":"/2019/07/19/POJ2777/"},{"title":"正则表达式(RegEx)集合（初级）","text":"正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式中的符号 table th:first-of-type { width: 110px; } table th:nth-of-type(3) { width: 135px } 符号 描述 示例 str 匹配文本字符串的字面值str abc str1|str2 匹配正则表达式str1|str2 abc|bca . 匹配任何字符（除\\n） abc.abc ^ 匹配字符串起始部分 ^Dear $ 匹配字符串终止部分 /str1/*str2$ * 匹配0次或者多次前面出现的正则表达式 [A-Za-z0-9]* + 匹配1次或者多次前面出现的正则表达式 [a-z]+\\.com ? 匹配0次或者1次前面出现的正则表达式 str? {N} 匹配N次前面出现的正则表达式 [A-Z]{3} {M,N} 匹配M到N次（包括M和N）前面出现的正则表达式 [0,9]{3,6} […] 匹配括号中说明的字符集的任意单一字符 [abc] […x-y…] 匹配x-y范围中的任意单一字符 [A-Za-z0-9] [^…] 不匹配此字符集中出现的任何一个字符，包括某一范围的字符（如果在此字符集中出现） [^aedv],[^A-Z] (*|+|?|{})? 用于匹配上面频繁出现/重复出现符号的非贪婪版本（*、+、?、{}） .*?[A-Z] (…) 匹配封闭的正则表达式，然后另存为子组 (A(B(C))) 正则表达式中的特殊字符 特殊字符 描述 示例 \\d 匹配任何十进制数字，与[0-9]一致(\\D与\\d相反，不匹配任何十进制数字) f\\d.txt \\w 匹配任何字母数字字符，与[A-Za-z0-9]相同（\\W与之相反） [A-Za-z]\\w+ \\s 匹配任何空格字符，与[\\n\\t\\r\\v\\f]相同(\\S与之相反) of\\sthe \\b 匹配任何单词边界（\\B与之相反） \\bThe\\b \\N 匹配已保存的子组N（参见上面的(…)） price:\\16 \\c 逐字匹配任何特殊字符c（即，仅按照字面意义匹配，不匹配特殊含义） \\.,\\\\,\\* \\A(\\Z) 匹配字符串的起始(结束)（如上面介绍的^和$） \\ADear 正则表达式中的扩展表示法 (?str)在正则表达式中嵌入一个或者多个特殊“标记”参数（或者通过函数/方法） (?:…)表示一个匹配不用保存的分组 (?P&lt;name&gt;)向一个仅由name标识而不是数字ID标识的正则分组匹配 (?P=name)在同一字符串中匹配由(?P)分组的之前文本 (?#…)表示注释，所有内容都被忽略 (?=…)匹配条件是如果…出现在之后的位置，而不使用输入字符串；称作正向前视断言 (?!…)匹配条件是如果…不出现在之后的位置，而不使用输入字符串；称作负向前视断言 (?&lt;=…)匹配条件是如果…出现在之前的位置，而不使用输入字符串；称作正向后视断言 (?&lt;!…)匹配条件是如果…不出现在之前的位置，而不是用输入字符串；称作负向后视断言 (?(id/name)Y|N)如果分组所提供的id或者name（名称）存在，就返回正则表达式的条件匹配Y，如果不存在，就返回N；|N是可选项（也就是说是可省略的）。ps: 有点像C++中的三目运算符 贪婪模式vs非贪婪模式〇 贪婪模式 在整个表达式匹配成功的前提下，尽可能多的匹配 〇 非贪婪模式 在整个表达式匹配成功的前提下，尽可能少的匹配 默认是贪婪模式","link":"/2019/08/05/RE1/"},{"title":"CodeForces - 12D Ball 线段树","text":"题目意思就是，road命令连接第A坐标和第B坐标的点。而line则是查看纵坐标C拉出的扫描线过几个联通块，而联通块中的数量和是多少。（具体的可以查看原题） 题解：其实是线段树一个简单的模拟，即并查集找联通块和联通块中点的数量，然后每次更新删除A点和B点的信息，重新建立A点和B点连接后的信息就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define fi first#define se second#define MP make_pair#define P pair&lt;int,int&gt;#define PLL pair&lt;ll,ll&gt;#define Sca(x) scanf(\"%d\",&amp;x)#define Sca2(x,y) scanf(\"%d%d\",&amp;x,&amp;y)#define Sca3(x,y,z) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z)#define Scl(x) scanf(\"%lld\",&amp;x)#define Scl2(x,y) scanf(\"%lld%lld\",&amp;x,&amp;y)#define Scl3(x,y,z) scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;z)#define Pri(x) printf(\"%d\\n\",x)#define Prl(x) printf(\"%lld\\n\",x)#define For(i,x,y) for(int i=x;i&lt;=y;i++)#define _For(i,x,y) for(int i=x;i&gt;=y;i--)#define FAST_IO std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);#define ll long longconst int INF=0x3f3f3f3f;const ll INFL=0x3f3f3f3f3f3f3f3f;const double Pi = acos(-1.0);using namespace std;template &lt;class T&gt;void tomax(T&amp;a,T b){ a=max(a,b); } template &lt;class T&gt;void tomin(T&amp;a,T b){ a=min(a,b); }const int N=1e5+5;struct Segt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define MID (tree[p].l+tree[p].r)&gt;&gt;1 struct Tree{ int l,r; int uck,val,lz[2]; inline void init(int left,int right){ l=left; r=right; uck=0; val=0; lz[0]=0; lz[1]=0; } void updata(int uckv,int valv){ uck+=uckv; val+=valv; lz[0]+=uckv; lz[1]+=valv; } }tree[N&lt;&lt;2|1]; void pushdown(int p){ tree[p].uck=tree[lc].uck+tree[rc].uck; tree[p].val=tree[lc].val+tree[rc].val; } void pushup(int p){ int one=tree[p].lz[0],two=tree[p].lz[1]; tree[lc].updata(one,two); tree[rc].updata(one,two); tree[p].lz[0]=0; tree[p].lz[1]=0; } void build(int l,int r,int p){ tree[p]=Tree{l,r,0,0,0,0}; if(l==r) return ; int mid=MID; build(l,mid,lc); build(mid+1,r,rc); } void updata(int l,int r,int p,int uckv,int valv){ if(l&gt;r) return ; if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r){ tree[p].updata(uckv,valv); return ; } if(tree[p].lz[0] || tree[p].lz[1]) pushup(p); int mid=MID; if(l&lt;=mid) updata(l,r,lc,uckv,valv); if(r&gt;mid) updata(l,r,rc,uckv,valv); pushdown(p); } P getans(int pos,int p){ if(tree[p].l==pos &amp;&amp; tree[p].r==pos) return MP(tree[p].uck,tree[p].val); if(tree[p].lz[0] || tree[p].lz[1]) pushup(p); int mid=MID; if(pos&lt;=mid) return getans(pos, lc); if(pos&gt;mid) return getans(pos, rc); }}t;struct Up{ int minn,maxx; } up[N];int num[N],tmp[N],uck[N],ans[N];int len=0;int find(int x){ return uck[x]==x ? x : uck[x]=find(uck[x]); }void merge(int x,int y){ int t1(find(x)),t2(find(y)); if(t1!=t2){ t.updata(up[t1].minn+1,up[t1].maxx,1,-1,-ans[t1]); t.updata(up[t2].minn+1,up[t2].maxx,1,-1,-ans[t2]); uck[t2]=t1; ans[t1]+=ans[t2]; tomax(up[t1].maxx,up[t2].maxx); tomin(up[t1].minn,up[t2].minn); t.updata(up[t1].minn+1,up[t1].maxx,1,1,ans[t1]); }}inline void dis(int n){ sort(tmp+1,tmp+1+n); len=unique(tmp+1,tmp+1+n) - tmp - 1; For(i,1,n) num[i]=lower_bound(tmp+1,tmp+1+len,num[i]) - tmp;}inline void init(int n){ dis(n); For(i,1,n){ uck[i]=i; ans[i]=1; up[i]=Up{num[i], num[i]}; }}int main(){ int T; Sca(T); while(T--){ int n; Sca(n); For(i,1,n){ int x; Sca(x); Sca(num[i]); tmp[i]=num[i]; } init(n); t.build(1,len,1); int m; Sca(m); while(m--){ char cmd[10]; scanf(\"%s\",cmd); if(cmd[0]=='r'){ int x,y; Sca2(x,y); x++; y++; merge(x,y); } else if(cmd[0]=='l'){ double x; scanf(\"%lf\",&amp;x); x+=0.5; x = lower_bound(tmp+1,tmp+1+len,x) - tmp; if(x==len+1) puts(\"0 0\"); else{ P out = t.getans(x,1); printf(\"%d %d\\n\",out.fi,out.se); } } } }}","link":"/2019/07/19/UVA11992/"},{"title":"Hexo 绑定个人域名（华为云版）","text":"个人使用的hexo主题是伊卡洛斯(icarus)，虽然应该对下面的操作没有影响，但姑且还是说一下好了。域名控制管理平台是华为云 1.购买域名(华为云版) 1、进入华为云域名注册https://www.huaweicloud.com/product/domain.html，搜索自己喜欢的域名。 2、选择自己喜欢的域名（建议选择常见的，比如说：com，cn，net之类的，考虑到兼容性的问题），然后进行购买。 3、选择好要购买的期限和域名信息模板（没有的自己建一个，里面的要填写的信息没有特别要讲究的）。 Node:要注意的就是域名购买后，域名信息要实名认证成功后，购买的域名才可以被解析（通俗的说：能被使用） 2、绑定域名 前提是域名到账户上，并且成功实名认证后 1、进入华为云控制台，在华为云服务搜索框中搜素 云解析服务 DNS，然后进入。 2、一般来说是在公网解析中，在里面可以看到你购买成功的域名，然后点击解析，不用管其它的，直接点击进行设置。填入信息后，确定即可添加成功。 table th:first-of-type { width: 100px; } 填写目录 填写信息 主机记录 旁边有个问号，里面有详解，我是直接填了www 类型 普通的只需要A、CNAME（详情的可以看后面的跟的说明），我选择的是CNAME 别名 不用管，没用到，选否 线路类型 普通的全网默认就行了 TTL 默认，5分钟 值 CNAME： 填写需要绑定的域名（例：genmcai.github.io） A： 填写需要绑定的IP（查看方法放下面） 权重 可选参数，解析记录的权重，可选参数，默认值为1。取值范围：0~100。当域名有多条某一类型的解析记录时，根据权重数值选择解析记录，权重数值越高，优先级越高 IP查看方法Ctrl+R 进入 运行 输入 cmd ，输入命令 Ping 域名(例：Ping genmcai.github.io) 下面出现的IPv4地址即是 A 所需的值 3、进入github，到存放网站的仓库，Settings -&gt; Options -&gt; GitHub Pages -&gt; Custom domain -&gt; 填写需要绑定的个人域名 点击save后，网站上会提示是否成功，如果失败并且自己解决不了，可以在下面留言，我看到后会尽力帮你解决。 4、最后一步，在hexo的根目录下source 中添加一个无后缀名的文件（文件名：CNAME），里面内容填写个人域名(例：www.genmcai.com，至于有些同学会问怎么写入，这个可以直接先txt填入内容后删掉后缀名，或者用VS code之类的打开无后缀名的文件，也能写入。 这一步可以说挺重要的，如果没有这个文件，hexo g -d提交后，页面就会变成404，这个时候重复第3个步骤就能恢复，不过每次都这样很麻烦，而且可能会清空博客访问记录。 至此，个人域名的绑定就结束了，重新使用自己的个人域名进行访问，就能访问到绑定的hexo了。如果出现错误，有可能是主题版本的原因，也有可能是其他的原因。欢迎有疑问的小伙伴在下面留言。","link":"/2019/08/03/hexo1/"},{"title":"常用正则表达式","text":"正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 — 菜鸟教程 中文字符 [\\u4e00-\\u9fa5] PS：unicode编码 双字节字符（包括汉字在内） [^\\x00-\\xff] 空白行 \\n\\s*\\r Email地址 [\\w!#$%&amp;’+/=?^_`{|}~-]+(?:.[\\w!#$%&amp;’+/=?^_`{|}~-]+)@(?:[\\w](?:[\\w-][\\w])?.)+[\\w](?:[\\w-]*[\\w])? 网址URL [a-zA-z]+://[^\\s]* 国内电话号码 \\d{3}-\\d{8}|\\d{4}-{7,8} 腾讯QQ号 [1-9][0-9]{4,} 中国邮政编码 [1-9]\\d{5}(?!\\d) 18位身份证号 ^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$ （年-月-日）格式日期 ([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))) 正整数 ^[1-9]\\d*$ 负整数 ^-[1-9]\\d*$ 整数 ^-?[1-9]\\d*$ 非负整数（正整数 + 0） ^[1-9]\\d*|0$ 非正整数（负整数 + 0） ^-[1-9]\\d*|0$ 正浮点数 ^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 负浮点数 ^-[1-9]\\d.\\d|-0.\\d[1-9]\\d$ 在线正则表达式测试地址：http://tool.oschina.net/regex/#","link":"/2019/08/06/RE2/"}],"tags":[{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"位运算","slug":"位运算","link":"/tags/位运算/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/正则表达式/"},{"name":"并查集","slug":"并查集","link":"/tags/并查集/"},{"name":"模拟","slug":"模拟","link":"/tags/模拟/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"}],"categories":[{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"正则表达式","slug":"正则表达式","link":"/categories/正则表达式/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"}]}